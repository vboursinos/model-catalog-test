{
  "models": [
    {
      "name": "random_forest_classifier",
      "mlTask": "classification_2",
      "incompatibleMetrics": [],
      "groups": [
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "bootstrap",
          "label": "Bootstrap",
          "description": "Whether bootstrap samples are used when building trees. If False, the whole dataset is used to build each tree.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When oob_score is True, bootstrap must be True. When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Sets the weights for all classes. If None, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)). The \u201cbalanced_subsample\u201d mode is the same as \u201cbalanced\u201d except that weights are computed based on the bootstrap sample for every tree grown.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced_subsample",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "gini",
                "entropy"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gini",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "The number of features to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": "sqrt",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_samples",
          "label": "Maximum samples",
          "description": "The number of samples to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": true,
          "constraintInformation": "When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.01
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of base estimators in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "bootstrap",
          "target": "max_samples",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0001,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "random_forest_classifier",
        "modelDescription": "Random Forest Classifier is a specialized type of tree-based model implementing meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It performs well on imbalanced datasets",
          "It is robust to outliers",
          "There is more generalization and less overfitting",
          "It is useful to extract feature importance"
        ],
        "disadvantages": [
          "It requires that features need to have some predictive power"
        ],
        "prime": [],
        "displayName": "Random Forest Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "perceptron_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Weights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "early_stopping",
          "label": "Early stopping",
          "description": "Whether to use early stopping to terminate training when validation score is not improving.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta0",
          "label": "Eta0",
          "description": "The initial learning rate for the 'constant', 'invscaling' or 'adaptive' schedules.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "The penalty (aka regularization term) to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "l1",
                "elasticnet",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "shuffle",
          "label": "Shuffle",
          "description": "Whether to shuffle samples in each iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "perceptron_classifier",
        "modelDescription": "The Perceptron Classifier is a linear classification model based on a simple artificial neural unit. It iteratively adjusts weights in the input features to find a hyperplane that separates two classes. It is well-suited for high-dimensional data and is one of the simplest types of classifiers.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Simple and easy to understand",
          "Fast to train",
          "Works well with high-dimensional data",
          "Low computational requirements"
        ],
        "disadvantages": [
          "Sensitive to feature scaling",
          "Not suitable for non-linearly separable data",
          "May not converge if data is not linearly separable",
          "Lacks probabilistic interpretation"
        ],
        "prime": [],
        "displayName": "Perceptron Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "hist_gradient_boosting_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": true,
      "hyperParameters": [
        {
          "name": "l2_regularization",
          "label": "L2 regularization",
          "description": "The L2 regularization parameter. Use 0 for no regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "auto",
                "binary_crossentropy",
                "categorical_crossentropy"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "auto",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_bins",
          "label": "Maximum bins",
          "description": "The maximum number of bins to use for non-missing values.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 256
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 255,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 31,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 51
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 20,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-07,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "hist_gradient_boosting_classifier",
        "modelDescription": "Histogram-based Gradient Boosting Classifier is much faster than the Gradient Boosting Classifier for big datasets (n_samples >= 10 000). It has native support for missing values (NaNs). During training, the tree grower learns at each split point whether samples with missing values should go to the left or right child, based on the potential gain. When predicting, samples with missing values are assigned to the left or right child consequently.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires no pre-processing of data like the normalization and the scaling of data"
        ],
        "disadvantages": [
          "It is sensitive to outliers",
          "It has the problem of overfitting",
          "It is computationally expensive"
        ],
        "prime": [],
        "displayName": "Histogram-based Gradient Boosting Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "gaussian_naivebayes_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "var_smoothing",
          "label": "Var smoothing",
          "description": "Portion of the largest variance of all features that is added to variances for calculation stability.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-09,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "gaussian_naivebayes_classifier",
        "modelDescription": "Gaussian Naive Bayes Classifier implements the Gaussian Naive Bayes training and classification algorithm for classification. The likelihood of the features is assumed to be Gaussian. It can perform online updates to model parameters via partial_fit.",
        "modelType": [
          "Bayesian Model"
        ],
        "advantages": [
          "It is computational efficient",
          "It performs well on small amounts of data",
          "It can handle irrelevant features nicely"
        ],
        "disadvantages": [
          "It has a strong assumption based on the shape of data",
          "It is not stable"
        ],
        "prime": [],
        "displayName": "Gaussian Naive Bayes Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "decision_tree_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "fast",
        "explainable"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Sets the weights for all classes. If None, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "gini",
                "entropy"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gini",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "The number of features to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node expressed as a fraction of all training samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.15
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "splitter",
          "label": "Splitter",
          "description": "The strategy used to choose the split at each node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "random",
                "best"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "best",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "decision_tree_classifier",
        "modelDescription": "Decision Trees Regressor predicts the value of a target variable by learning simple decision rules inferred from the data features.",
        "modelType": [
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires no pre-processing of data like the normalization and the scaling of data  Missing values in the data also do not affect"
        ],
        "disadvantages": [
          "A small change in the data can cause a large change",
          "It is computational expensive"
        ],
        "prime": [],
        "displayName": "Decision Tree Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": true,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "prior_dummy_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "prior_dummy_classifier",
        "modelDescription": "The prior dummy classifier always returns the most frequent class label from the training data. It's prediction probabilities match the class distribution of the training data.",
        "modelType": [
          "Baseline Model"
        ],
        "advantages": [
          "Easily explainable.",
          "Fast to train.",
          "Provides a reference with which to compare other models."
        ],
        "disadvantages": [
          "Ignores all feature information.",
          "Poor performance."
        ],
        "prime": [],
        "displayName": "Prior Dummy Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "extra_trees_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "bootstrap",
          "label": "Bootstrap",
          "description": "Whether bootstrap samples are used when building trees. If False, the whole dataset is used to build each tree.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When oob_score is True, bootstrap must be True.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Sets the weights for all classes. If None, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)). The \u201cbalanced_subsample\u201d mode is the same as \u201cbalanced\u201d except that weights are computed based on the bootstrap sample for every tree grown.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced_subsample",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "gini",
                "entropy"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gini",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "The number of features to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "sqrt",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_samples",
          "label": "Maximum samples",
          "description": "The number of samples to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.9999,
          "constraint": true,
          "constraintInformation": "When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of base estimators in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "bootstrap",
          "target": "max_samples",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0001,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "extra_trees_classifier",
        "modelDescription": "The Extremely Randomized Trees (Extra-Trees) Classifier is an ensemble model that builds multiple randomized decision trees and averages their predictions. This approach aims to improve accuracy and reduce overfitting.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "Robust to overfitting",
          "Highly parallelizable",
          "Provides feature importance",
          "Quick to train",
          "Versatile"
        ],
        "disadvantages": [
          "Low interpretability",
          "High memory usage",
          "Predictive variability",
          "Less accurate than some boosting methods",
          "Requires hyperparameter tuning"
        ],
        "prime": [],
        "displayName": "Extremely Randomized Tree Ensemble Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "gaussian_process_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "max_iter_predict",
          "label": "Maximum number of iterations",
          "description": "The maximum number of iterations in Newton's method for approximating the posterior during predict. Smaller values will reduce computation time at the cost of worse results.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_restarts_optimizer",
          "label": "Number of restarts",
          "description": "The number of restarts of the optimizer for finding the kernel's parameters which maximize the log-marginal likelihood. The first run of the optimizer is performed from the kernel's initial parameters, the remaining ones (if any) from thetas sampled log-uniform randomly from the space of allowed theta-values. If greater than 0, all bounds must be finite. Note that n_restarts_optimizer == 0 implies that one run is performed.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "gaussian_process_classifier",
        "modelDescription": "Gaussian Process Classifier is a nonparametric, bayesian probabilistic classification using a Gaussian process as a prior over random functions and Laplace approximation as the non-Gaussian posterior.",
        "modelType": [
          "Bayesian Model",
          "Kernel Model"
        ],
        "advantages": [
          "It performs well on small datasets",
          "It has the ability to provide uncertainty measurements on the predictions",
          "It has the flexibility in using different kernels"
        ],
        "disadvantages": [
          "It loses efficiency in high dimensional spaces"
        ],
        "prime": [],
        "displayName": "Gaussian Process Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "gradient_boosting_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "friedman_mse",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "friedman_mse",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "exponential",
                "deviance"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "deviance",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "The number of features to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node expressed as a fraction of all training samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node expressed as a fraction of all training samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of base estimators in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "Subsample ratio of the training instances. Setting it to 0.5 means that XGBoost would randomly sample half of the training data prior to growing trees. and this will prevent overfitting. Subsampling will occur once in every boosting iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "gradient_boosting_classifier",
        "modelDescription": "Gradient Boosting Classifier builds an additive model in a forward stage-wise fashion; it allows for the optimization of arbitrary differentiable loss functions. In each stage, n_classes_ classifier trees are fitted on the negative gradient of the binomial or multinomial deviance loss function.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires no pre-processing of data like the normalization and the scaling of data"
        ],
        "disadvantages": [
          "It is sensitive to outliers",
          "It has the problem of overfitting",
          "It is computationally expensive"
        ],
        "prime": [],
        "displayName": "Gradient Boosting Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "uniform_dummy_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "uniform_dummy_classifier",
        "modelDescription": "The uniform dummy classifier makes predictions by sampling from the distribution of the training class labels.",
        "modelType": [
          "Baseline Model"
        ],
        "advantages": [
          "Easily explainable.",
          "Fast to train.",
          "Provides a reference with which to compare other models."
        ],
        "disadvantages": [
          "Ignores all feature information.",
          "Poor performance."
        ],
        "prime": [],
        "displayName": "Uniform Dummy Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "nearest_centroid_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss-test",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "metric",
          "label": "Metric",
          "description": "The metric to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "euclidean"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "euclidean",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "shrink_threshold",
          "label": "Shrink threshold",
          "description": "Threshold for shrinking centroids to remove features.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform_test",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "nearest_centroid_classifier",
        "modelDescription": "Nearest Centroid Classifier is a specialized type of neighbor classifier model which represents each class by the centroid of its members.",
        "modelType": [
          "Nearest Neighbours Model"
        ],
        "advantages": [
          "It is easy to understand and implement",
          "It works well when classes are compact and far from each other"
        ],
        "disadvantages": [
          "It has poor performance for complex classes",
          "It can not handle outliers noisy data and missing data well"
        ],
        "prime": [],
        "displayName": "Nearest Centroid Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base_2",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "linearsvc_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 25.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Weights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "dual",
          "label": "Dual",
          "description": "Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=False when n_samples > n_features.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2. When dual is False, loss must be squared_hinge.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "intercept_scaling",
          "label": "Intercept scaling",
          "description": "Useful only when the solver 'liblinear' is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \u201csynthetic\u201d feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Specifies the loss function. inge is the standard SVM loss while squared_hingeis the square of the hinge loss.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "hinge",
                "squared_hinge"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_hinge",
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2. When dual is False, loss must be squared_hinge.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 500,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "multi_class",
          "label": "Multi-class",
          "description": "Determines the multi-class strategy if y contains more than two classes.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "crammer_singer",
                "ovr"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "ovr",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "Specifies the norm used in the penalization. The l2 penalty is the standard used in SVC. The l1 leads to coef_vectors that are sparse.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "l2",
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "dual",
          "target": "penalty",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l2"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1",
                    "l2"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "dual",
          "target": "loss",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "hinge",
                    "squared_hinge"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "squared_hinge"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "linearsvc_classifier",
        "modelDescription": "Linear Support Vector Machine Classifier is similar to Support Vector Machine Classifier with the linear kernel but has more flexibility in the choice of penalties and loss functions.",
        "modelType": [
          "Kernel Model",
          "Support Vector Machine Model"
        ],
        "advantages": [
          "It performs well in higher dimension spaces",
          "It is robust to outliers"
        ],
        "disadvantages": [
          "It is computationally expensive",
          "It is tricky in selecting the appropriate kernel function"
        ],
        "prime": [],
        "displayName": "Linear Support Vector Machine Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "svm_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "break_ties",
          "label": "Break ties",
          "description": "f true, decision_function_shape='ovr', and number of classes > 2, predict will break ties according to the confidence values of decision_function; otherwise the first class among the tied classes is returned.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When decision_function_shape is ovo, break_ties must be False.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Sets the weights for all classes. If None, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "coef0",
          "label": "Coefficient 0",
          "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "decision_function_shape",
          "label": "Decision function shape",
          "description": "Whether to return a one-vs-rest (ovr) decision function of shape (n_samples, n_classes) as all other classifiers, or the original one-vs-one (ovo) decision function of libsvm.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "ovo",
                "ovr"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "ovr",
          "constraint": true,
          "constraintInformation": "When decision_function_shape is ovo, break_ties must be False.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "degree",
          "label": "Degree",
          "description": "Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 3,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "auto",
                "scale"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "scale",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "kernel",
          "label": "Kernel",
          "description": "Specifies the kernel type to be used in the algorithm. It must be one of, 'poly', 'rbf', 'sigmoid', 'precomputed' or a callable. If none is given, 'rbf' will be used. If a callable is given it is used to precompute the kernel matrix.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "poly",
                "sigmoid",
                "rbf"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "rbf",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 2000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shrinking",
          "label": "Shrinking",
          "description": "Whether to use the shrinking heuristic.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "decision_function_shape",
          "target": "break_ties",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "ovo"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "ovr"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False",
                    "True"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "svm_classifier",
        "modelDescription": "Support Vector Machine Classifier builds a hyperplane with support vectors to separate marked example points.",
        "modelType": [
          "Kernel Model",
          "Support Vector Machine Model"
        ],
        "advantages": [
          "It performs well in higher dimension spaces",
          "It is robust to outliers",
          "It is memory efficient"
        ],
        "disadvantages": [
          "It is computationally expensive",
          "It is tricky in selecting the appropriate kernel function"
        ],
        "prime": [],
        "displayName": "Support Vector Machine Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "logistic_regression_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "fast",
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength (positive float); smaller values indicate stronger regularization, which helps prevent overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Enables control over the weight of different the classes in your training dataset, which can be beneficial when working with imbalanced data. If set to None, all classes are given equal weight. If set to balanced, the class weights are adjusted proportionally to their frequencies in the input data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "dual",
          "label": "Dual",
          "description": "Boolean indicating whether to use the dual or primal formulation of the optimization problem.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2, and solver must be liblinear.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Boolean indicating whether to calculate the model's intercept; if False, data is expected to be centered and no intercept is used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "intercept_scaling",
          "label": "Intercept scaling",
          "description": "Applicable when using 'liblinear' solver and 'fit_intercept' is True; adds a synthetic feature with a constant value equal to intercept_scaling to the instance vector.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "Elastic-Net mixing parameter (0 <= l1_ratio <= 1); controls the balance between L1 and L2 regularization.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When penalty is elasticnet, l1_ratio must be between 0 and 1.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations for the solver to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 50,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "multi_class",
          "label": "Multi_class",
          "description": "Strategy for handling multi-class problems; 'ovr' fits a binary problem for each label, while 'multinomial' minimizes the multinomial loss across the entire probability distribution.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "auto",
                "ovr",
                "multinomial"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "auto",
          "constraint": true,
          "constraintInformation": "When solver is liblinear, multi_class must be auto or ovr.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "Norm of the regularization penalty (e.g., 'l1', 'l2', 'elasticnet').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "none",
                "l1",
                "elasticnet",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l2",
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2. When penalty is none, solver must be one of (newton-cg, lbfgs, sag, saga). When penalty is l1, solver must be saga or liblinear. When penalty is elasticnet, solver must be saga. When penalty is elasticnet, l1_ratio must be between 0 and 1.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "solver",
          "label": "Solver",
          "description": "Algorithm used to solve the optimization problem (e.g., 'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "newton-cg",
                "liblinear",
                "sag",
                "saga",
                "lbfgs"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "lbfgs",
          "constraint": true,
          "constraintInformation": "When dual is True, solver must be liblinear. When penalty is none, solver must be one of (newton-cg, lbfgs, sag, saga). When penalty is l1, solver must be saga or liblinear. When penalty is elasticnet, solver must be saga. When solver is liblinear, multi_class must be auto or ovr.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance for stopping criterion; solver converges when the residual's maximum norm is below this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "dual",
          "target": "solver",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "liblinear"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "newton-cg",
                    "liblinear",
                    "sag",
                    "saga",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "multi_class",
          "target": "solver",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "auto",
                    "ovr"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "newton-cg",
                    "liblinear",
                    "sag",
                    "saga",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "multinomial"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga",
                    "newton-cg",
                    "sag",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "penalty",
          "target": "l1_ratio",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "none",
                    "l1",
                    "l2"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "elasticnet"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        },
        {
          "source": "penalty",
          "target": "solver",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga",
                    "liblinear"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l2"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "newton-cg",
                    "liblinear",
                    "sag",
                    "saga",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "elasticnet"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "none"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga",
                    "newton-cg",
                    "sag",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "logistic_regression_classifier",
        "modelDescription": "The logistic regression classifier is a linear model for classification, implemented in the scikit-learn library. It estimates the probability of an instance belonging to a specific class by fitting a logistic function to the input data. The model supports various regularization techniques, solvers, and multi-class strategies.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Ease of implementation and effectiveness",
          "Computational efficiency",
          "Low likelihood of overfitting"
        ],
        "disadvantages": [
          "Struggles with non-linear data",
          "Impaired performance due to irrelevant or highly correlated features"
        ],
        "prime": [],
        "displayName": "Logistic Regression Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "sgd_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "average",
          "label": "Average",
          "description": "When set to True, computes the averaged SGD weights accross all updates and stores the result in the coef_ attribute.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Weights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "early_stopping",
          "label": "Early stopping",
          "description": "Whether to use early stopping to terminate training when validation score is not improving.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Value for numerical stability in adam. Only used when solver='adam'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta0",
          "label": "Eta0",
          "description": "The initial learning rate for the 'constant', 'invscaling' or 'adaptive' schedules.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "The Elastic-Net mixing parameter, with 0 <= l1_ratio <= 1.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.15,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "optimal",
                "invscaling",
                "adaptive",
                "constant"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "optimal",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "hinge",
                "squared_hinge",
                "huber",
                "log",
                "epsilon_insensitive",
                "modified_huber",
                "squared_error",
                "perceptron",
                "squared_epsilon_insensitive"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "hinge",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "The penalty (aka regularization term) to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "elasticnet",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l2",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "power_t",
          "label": "Power t",
          "description": "The exponent for inverse scaling learning rate.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 50.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "shuffle",
          "label": "Shuffle",
          "description": "Whether to shuffle samples in each iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "sgd_classifier",
        "modelDescription": "Stochastic Gradient Descent Classifier is a linear classifier with stochastic gradient descent (SGD) training. The gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "It is computationally efficient",
          "It has fast convergence for larger datasets"
        ],
        "disadvantages": [
          "It is not stable"
        ],
        "prime": [],
        "displayName": "Stochastic Gradient Descent Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "passive_aggressive_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "average",
          "label": "Average",
          "description": "When set to True, computes the averaged SGD weights accross all updates and stores the result in the coef_ attribute.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Weights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "early_stopping",
          "label": "Early stopping",
          "description": "Whether to use early stopping to terminate training when validation score is not improving.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "hinge",
                "squared_hinge"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "hinge",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shuffle",
          "label": "Shuffle",
          "description": "Whether to shuffle samples in each iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "passive_aggressive_classifier",
        "modelDescription": "Passive Aggressive Classifier is a family of algorithms for large-scale learning. It is similar to the Perceptron in that they do not require a learning rate but contrary to the Perceptron in that they include a regularization parameter.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "It is suitable for large-scale learning"
        ],
        "disadvantages": [
          "It has the problem of learning many simple functions"
        ],
        "prime": [],
        "displayName": "Passive Aggressive Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "stratified_dummy_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "stratified_dummy_classifier",
        "modelDescription": "The stratified dummy classifier makes predictions by sampling from the distribution of the training class labels.",
        "modelType": [
          "Baseline Model"
        ],
        "advantages": [
          "Easily explainable.",
          "Fast to train.",
          "Provides a reference with which to compare other models."
        ],
        "disadvantages": [
          "Ignores all feature information.",
          "Poor performance."
        ],
        "prime": [],
        "displayName": "Stratified Dummy Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "quadratic_discriminant_analysis_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "reg_param",
          "label": "Regularise covariance estimates",
          "description": "Regularizes the per-class covariance estimates by transforming S2 as S2 = (1 - reg_param) * S2 + reg_param * np.eye(n_features), where S2 corresponds to the scaling_ attribute of a given class.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "quadratic_discriminant_analysis_classifier",
        "modelDescription": "Quadratic Discriminant Analysis Classifier generates a quadratic decision boundary via fitting class conditional densities to the data and applying Bayes rule. In this model, all classes are assumed to share the same covariance matrix and fitted by the Gaussian density.",
        "modelType": [
          "Bayesian Model"
        ],
        "advantages": [
          "It has a closed-form solution",
          "It is easy to implement",
          "It has no hyperparameters to tune"
        ],
        "disadvantages": [
          "It requires normal distribution assumption on features"
        ],
        "prime": [],
        "displayName": "Quadratic Discriminant Analysis Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "linear_discriminant_analysis_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "shrinkage",
          "label": "Shrinkage",
          "description": "Shrinkage parameter.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When solver is svd, shrinkage must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "solver",
          "label": "Solver",
          "description": "Solver to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "lsqr",
                "svd",
                "eigen"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "svd",
          "constraint": true,
          "constraintInformation": "When solver is svd, shrinkage must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "solver",
          "target": "shrinkage",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "svd"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "lsqr",
                    "eigen"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "linear_discriminant_analysis_classifier",
        "modelDescription": "Linear Discriminant Analysis Classifier generates a linear decision boundary via fitting class conditional densities to the data and applying Bayes rule. In this model, all classes are assumed to share the same covariance matrix and fitted by the Gaussian density.",
        "modelType": [
          "Bayesian Model"
        ],
        "advantages": [
          "It has a closed-form solution",
          "It is easy to implement",
          "It has no hyperparameters to tune"
        ],
        "disadvantages": [
          "It requires normal distribution assumption on features"
        ],
        "prime": [],
        "displayName": "Linear Discriminant Analysis Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "nlp_sequence_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "batch_size",
          "label": "Batch Size",
          "description": "The batch size parameter determines the number of training examples used to calculate the gradient update in each iteration of the optimization process, influencing both the training speed and the model's generalization performance.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 129
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 32,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "epochs",
          "label": "Epochs",
          "description": "Number of epochs to train the model.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 2,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning Rate",
          "description": "Learning rate for the optimizer.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.0001
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 5e-05,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "lr_scheduler_type",
          "label": "Learning Rate Scheduler",
          "description": "Specifies the type of learning rate scheduler used during training, controlling how the learning rate is adjusted over time to improve model convergence and performance.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "cosine_with_restarts",
                "linear",
                "constant_with_warmup",
                "cosine",
                "constant",
                "polynomial"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "linear",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_length",
          "label": "Max Length",
          "description": "Maximum length of the input sequence.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 32,
                  "stop": 513
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 64,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "model",
          "label": "Transformer Model Name",
          "description": "Name of the transformer model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "deepmind/language-perceiver",
                "google/electra-base-discriminator",
                "albert-base-v2",
                "roberta-base",
                "distilbert-base-uncased",
                "facebook/bart-base",
                "bert-base-uncased",
                "gpt2"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "bert-base-uncased",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "warmup_ratio",
          "label": "Warmup Ratio",
          "description": "Determines the proportion of total training steps dedicated to the warm-up phase, during which the learning rate gradually increases to its initial value to ensure stable training.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "nlp_sequence_classifier",
        "modelDescription": "The NLP Sequence Classifier is an interface to Hugging Face's Transformers, designed to simplify and optimize text classification tasks. Leveraging pre-trained models from the Transformers library, this classifier aims to offer state-of-the-art performance in natural language understanding.",
        "modelType": [
          "Deep Learning Model"
        ],
        "advantages": [
          "Leverages Pre-trained Models: By utilizing the pre-trained models from Hugging Face's extensive library, the NLP Sequence Classifier offers a quick and powerful way to benefit from the latest advancements in NLP without the need for extensive data or computational resources.",
          "Ease of Use: The wrapper simplifies the application of complex transformer-based models into text classification tasks, making it easier for developers to integrate advanced NLP functionalities into their applications.",
          "Highly Versatile: Given the underlying architecture, the NLP Sequence Classifier can be adapted to various text classification problems ranging from sentiment analysis to topic classification, providing high-quality results across a wide array of use-cases."
        ],
        "disadvantages": [
          "Computational Overhead: Utilizing transformer models generally comes with high computational costs in terms of memory and processing power, especially for large datasets or complex architectures.",
          "Lack of Interpretability: Transformer models, being highly complex, do not offer straightforward ways to interpret their decisions, making them less ideal for applications where model interpretability is crucial.",
          "Dependence on Pre-trained Models: While leveraging pre-trained models is an advantage in terms of performance and speed, it may limit customization and adaptation to highly specific or nuanced tasks that require training from scratch."
        ],
        "prime": [
          "model"
        ],
        "displayName": "NLP Sequence Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "huggingface"
      }
    },
    {
      "name": "intelex_logistic_regression_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength (positive float); smaller values indicate stronger regularization, which helps prevent overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Enables control over the weight of different the classes in your training dataset, which can be beneficial when working with imbalanced data. If set to None, all classes are given equal weight. If set to balanced, the class weights are adjusted proportionally to their frequencies in the input data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "dual",
          "label": "Dual",
          "description": "Boolean indicating whether to use the dual or primal formulation of the optimization problem.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2, and solver must be liblinear.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Boolean indicating whether to calculate the model's intercept; if False, data is expected to be centered and no intercept is used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "intercept_scaling",
          "label": "Intercept scaling",
          "description": "Applicable when using 'liblinear' solver and 'fit_intercept' is True; adds a synthetic feature with a constant value equal to intercept_scaling to the instance vector.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "Elastic-Net mixing parameter (0 <= l1_ratio <= 1); controls the balance between L1 and L2 regularization.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When penalty is elasticnet, l1_ratio must be between 0 and 1.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations for the solver to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 50,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "multi_class",
          "label": "Multi_class",
          "description": "Strategy for handling multi-class problems; 'ovr' fits a binary problem for each label, while 'multinomial' minimizes the multinomial loss across the entire probability distribution.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "auto",
                "ovr",
                "multinomial"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "auto",
          "constraint": true,
          "constraintInformation": "When solver is liblinear, multi_class must be auto or ovr.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "Norm of the regularization penalty (e.g., 'l1', 'l2', 'elasticnet').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "none",
                "l1",
                "elasticnet",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l2",
          "constraint": true,
          "constraintInformation": "When dual is True, penalty must be l2. When penalty is none, solver must be one of (newton-cg, lbfgs, sag, saga). When penalty is l1, solver must be saga or liblinear. When penalty is elasticnet, solver must be saga. When penalty is elasticnet, l1_ratio must be between 0 and 1.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "solver",
          "label": "Solver",
          "description": "Algorithm used to solve the optimization problem (e.g., 'newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "newton-cg",
                "liblinear",
                "sag",
                "saga",
                "lbfgs"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "lbfgs",
          "constraint": true,
          "constraintInformation": "When dual is True, solver must be liblinear. When penalty is none, solver must be one of (newton-cg, lbfgs, sag, saga). When penalty is l1, solver must be saga or liblinear. When penalty is elasticnet, solver must be saga. When solver is liblinear, multi_class must be auto or ovr.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance for stopping criterion; solver converges when the residual's maximum norm is below this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "dual",
          "target": "solver",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "liblinear"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "newton-cg",
                    "liblinear",
                    "sag",
                    "saga",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "multi_class",
          "target": "solver",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "auto",
                    "ovr"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "newton-cg",
                    "liblinear",
                    "sag",
                    "saga",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "multinomial"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga",
                    "newton-cg",
                    "sag",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "penalty",
          "target": "l1_ratio",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "none",
                    "l1",
                    "l2"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "elasticnet"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        },
        {
          "source": "penalty",
          "target": "solver",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga",
                    "liblinear"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l2"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "newton-cg",
                    "liblinear",
                    "sag",
                    "saga",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "elasticnet"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "none"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "saga",
                    "newton-cg",
                    "sag",
                    "lbfgs"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "intelex_logistic_regression_classifier",
        "modelDescription": "The logistic regression classifier is a linear model for classification, implemented using the scikit-learn library. It estimates the probability of an instance belonging to a specific class by fitting a logistic function to the input data. The model supports various regularization techniques, solvers, and multi-class strategies.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Logistic regression provides probabilities of each class label, which helps the user judge the confidence of predictions",
          "It is simple to understand and explain, which supports interpretability.",
          "It handles binary and multiclass classification problems, enhancing its applicability."
        ],
        "disadvantages": [
          "Logistic regression assumes linearity of independent variables and log odds, limiting its use in complex nonlinear relationships.",
          "It might be prone to overfitting, particularly in scenarios with many input features.",
          "It's not ideal for large number of features or variables, due to the risk of multicollinearity."
        ],
        "prime": [],
        "displayName": "Intelex Logistic Regression Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "intelex_random_forest_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "bootstrap",
          "label": "Bootstrap",
          "description": "Whether bootstrap samples are used when building trees. If False, the whole dataset is used to build each tree.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When oob_score is True, bootstrap must be True. When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Sets the weights for all classes. If None, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)). The \u201cbalanced_subsample\u201d mode is the same as \u201cbalanced\u201d except that weights are computed based on the bootstrap sample for every tree grown.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced_subsample",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "gini",
                "entropy"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gini",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "The number of features to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": "sqrt",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_samples",
          "label": "Maximum samples",
          "description": "The number of samples to draw from X to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": true,
          "constraintInformation": "When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 2,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.01
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of base estimators in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "bootstrap",
          "target": "max_samples",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0001,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "intelex_random_forest_classifier",
        "modelDescription": "Random Forest Classifier is a specialized type of tree-based model implementing meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It performs well on imbalanced datasets",
          "It is robust to outliers",
          "There is more generalization and less overfitting",
          "It is useful to extract feature importance"
        ],
        "disadvantages": [
          "It requires that features need to have some predictive power"
        ],
        "prime": [],
        "displayName": "Intelex Random Forest Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "intelex_svm_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "break_ties",
          "label": "Break ties",
          "description": "f true, decision_function_shape='ovr', and number of classes > 2, predict will break ties according to the confidence values of decision_function; otherwise the first class among the tied classes is returned.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When decision_function_shape is ovo, break_ties must be False.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Sets the weights for all classes. If None, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "coef0",
          "label": "Coefficient 0",
          "description": "Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "decision_function_shape",
          "label": "Decision function shape",
          "description": "Whether to return a one-vs-rest (ovr) decision function of shape (n_samples, n_classes) as all other classifiers, or the original one-vs-one (ovo) decision function of libsvm.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "ovo",
                "ovr"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "ovr",
          "constraint": true,
          "constraintInformation": "When decision_function_shape is ovo, break_ties must be False.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "degree",
          "label": "Degree",
          "description": "Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 3,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "auto",
                "scale"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "scale",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "kernel",
          "label": "Kernel",
          "description": "Specifies the kernel type to be used in the algorithm. It must be one of, 'poly', 'rbf', 'sigmoid', 'precomputed' or a callable. If none is given, 'rbf' will be used. If a callable is given it is used to precompute the kernel matrix.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "poly",
                "sigmoid",
                "rbf"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "rbf",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 2000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shrinking",
          "label": "Shrinking",
          "description": "Whether to use the shrinking heuristic.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "decision_function_shape",
          "target": "break_ties",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "ovo"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "ovr"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False",
                    "True"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "intelex_svm_classifier",
        "modelDescription": "Support Vector Machine Classifier builds a hyperplane with support vectors to separate marked example points.",
        "modelType": [
          "Kernel Model",
          "Support Vector Machine Model"
        ],
        "advantages": [
          "Support Vector Machines (SVMs) perform well in high-dimensional spaces, making them suitable for datasets with many features.",
          "They use a subset of training points in the decision function (support vectors), making them memory efficient.",
          "They're versatile, as different Kernel functions can be specified for the decision function."
        ],
        "disadvantages": [
          "They are not efficient with large datasets because the training time can be cubic in the size of the dataset.",
          "SVMs don't provide probability estimates directly, which can be a disadvantage in certain use cases.",
          "If the number of features greatly exceeds the number of samples, the SVM can perform poorly and overfitting can occur."
        ],
        "prime": [],
        "displayName": "Intelex Support Vector Machine Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "feature_reduction_stacking_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "feature_reduction_stacking_classifier",
        "modelDescription": "A meta-classifier is fitted on the predictions of a number of base models, which may be reduced to a lower dimensional space. It is combined with the initial training data, which is reduced to a lower dimensional space.",
        "modelType": [
          "Ensemble Model"
        ],
        "advantages": [],
        "disadvantages": [],
        "prime": [],
        "displayName": "Feature Reduction Stacking Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "dynamic",
        "dependencyGroup": "stacking"
      }
    },
    {
      "name": "stacking_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "stacking_classifier",
        "modelDescription": "A meta-classifier is fitted on the predictions of a number of base models, which may be combined with the initial training data.",
        "modelType": [
          "Ensemble Model"
        ],
        "advantages": [],
        "disadvantages": [],
        "prime": [],
        "displayName": "Stacking Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "dynamic",
        "dependencyGroup": "stacking"
      }
    },
    {
      "name": "base_reduction_stacking_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "base_reduction_stacking_classifier",
        "modelDescription": "A meta-classifier is fitted on the predictions of a number of base models and the base predictions space is reduced to a lower dimensional space. It may be combined with the initial training data.",
        "modelType": [
          "Ensemble Model"
        ],
        "advantages": [],
        "disadvantages": [],
        "prime": [],
        "displayName": "Base Reduction Stacking Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "dynamic",
        "dependencyGroup": "stacking"
      }
    },
    {
      "name": "lightgbm_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "fast",
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "boosting_type",
          "label": "Boosting type",
          "description": "The type of boosting to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "dart",
                "goss",
                "gbdt",
                "rf"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gbdt",
          "constraint": true,
          "constraintInformation": "When boosting_type is rf, subsample must be in (0, 1), and subsample_freq must be greater than or equal to 1. When boosting_type is goss, subsampling is not used. The subsample ratio is ignored and subsample_freq must be smaller than or equal to 0.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "class_weight",
          "label": "Class weight",
          "description": "Weights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one. The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "balanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bytree",
          "label": "Column subsample ratio by tree",
          "description": "The subsample ratio of columns when constructing each tree. Subsampling occurs once for every tree constructed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.01,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_child_samples",
          "label": "Minimum childs per sample",
          "description": "Minimal number of data in one leaf. Can be used to deal with over-fitting.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 51
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 20,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_child_weight",
          "label": "Minimum child weight",
          "description": "Minimum sum of instance weight (hessian) needed in a child.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 0.25
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_split_gain",
          "label": "Minimal gain to split",
          "description": "The minimal gain to perform split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 5.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of base estimators in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "num_leaves",
          "label": "Number of leaves",
          "description": "The maximum number of leaves in one tree.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 31,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "reg_alpha",
          "label": "Regularization alpha",
          "description": "L1 regularization term on weights. Increasing this value will make model more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10000.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "reg_lambda",
          "label": "Regularization lambda",
          "description": "L2 regularization term on weights. Increasing this value will make model more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10000.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "Subsample ratio of the training instances. Setting it to 0.5 means that LightGBM would randomly sample half of the training data prior to growing trees. and this will prevent overfitting. Subsampling will occur once in every boosting iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.5,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": true,
          "constraintInformation": "When boosting_type is rf, subsample must be in (0, 1).",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "subsample_for_bin",
          "label": "Subsamples to construct bin",
          "description": "Number of data that sampled to construct feature discrete bins.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 100,
                  "stop": 1000001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 200000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "subsample_freq",
          "label": "Subsample frequency",
          "description": "Frequency for bagging.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 0,
          "constraint": true,
          "constraintInformation": "When boosting_type is rf, subsample_freq must be greater than or equal to 1. When boosting_type is goss, subsample_freq must be smaller than or equal to 0.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "boosting_type",
          "target": "subsample",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "rf"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": null,
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": false,
                      "lower": 0.1,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "goss"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": null,
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 1.0,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "dart",
                    "gbdt"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": null,
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.1,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        },
        {
          "source": "boosting_type",
          "target": "subsample_freq",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "rf"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": [
                    {
                      "start": 1,
                      "stop": 11
                    }
                  ]
                },
                "categoricalSet": null,
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "goss"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": [
                    {
                      "start": 0,
                      "stop": 1
                    }
                  ]
                },
                "categoricalSet": null,
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "dart",
                    "gbdt"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": [
                    {
                      "start": 0,
                      "stop": 11
                    }
                  ]
                },
                "categoricalSet": null,
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "lightgbm_classifier",
        "modelDescription": "LightGBM Classifier is a tree-based ensemble model. It buckets continuous feature values into discrete bins and uses a gradient-based one-side sampling to split values. In comparison with XGBoost and CatBoost, LightGBM performs poorly on categorical datasets but has a similar performance to XGBoost on numerical datasets with fewer training time.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It is computational efficient",
          "It performs well on large sized datasets"
        ],
        "disadvantages": [
          "It has the problem of overfitting especially on small data"
        ],
        "prime": [],
        "displayName": "LightGBM Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "lightgbm"
      }
    },
    {
      "name": "fista_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Weight of the loss term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Weight of the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta",
          "label": "Eta",
          "description": "Decrease factor for line-search procedure.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1.5,
                  "upper": 5.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 2.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "log",
                "squared_hinge",
                "log_margin"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_hinge",
          "constraint": true,
          "constraintInformation": "When multiclass is False, loss must be squared_hinge.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_steps",
          "label": "Maximum number of steps",
          "description": "Maximum number of steps to use during the line search.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 30,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "multiclass",
          "label": "Multiclass",
          "description": "Whether to use a direct multiclass formulation (True) or one-vs-rest (False).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When multiclass is False, loss must be squared_hinge.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Loss",
          "description": "The regularization function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "l1/l2",
                "simplex",
                "tv1d"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l1",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "sigma",
          "label": "Sigma",
          "description": "Constant used in the line search sufficient decrease condition.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1e-05,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "multiclass",
          "target": "loss",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "squared_hinge"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "log",
                    "squared_hinge",
                    "log_margin"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "fista_classifier",
        "modelDescription": "An estimator that employs the Fast Iterative Shrinkage-Thresholding Algorithm (FISTA) for training linear classifiers. Designed for fast convergence, FISTA is particularly well-suited for large-scale and high-dimensional problems. It encourages sparse solutions and is efficient in terms of memory usage. The algorithm is ideal for convex optimization problems and offers flexibility in regularization techniques.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Fast convergence, especially suitable for large datasets.",
          "Encourages sparse solutions, advantageous in high-dimensional settings.",
          "Resource-efficient, doesn't require storing large intermediate matrices."
        ],
        "disadvantages": [
          "Sensitive to the choice of hyperparameters, requiring careful tuning.",
          "May suffer from numerical instabilities."
        ],
        "prime": [],
        "displayName": "Fast Iterative Shrinkage/Thresholding Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "cd_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Weight of the loss term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "Cd",
          "label": "C when doing debiasing",
          "description": "Value of `C` when doing debiasing.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Weight of the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "beta",
          "label": "Beta",
          "description": "Multiplicative constant used in the backtracking line search.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "debiasing",
          "label": "Debiasing",
          "description": "Whether to refit the model using l2 penalty (only useful if penalty='l1' or penalty='l1/l2').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "modified_huber",
                "squared_hinge",
                "log",
                "squared"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_hinge",
          "constraint": true,
          "constraintInformation": "When multiclass is True, loss must be squared_hinge or log.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 50,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_steps",
          "label": "Maximum number of steps",
          "description": "Maximum number of steps to use during the line search.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "auto"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "auto",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "multiclass",
          "label": "Multiclass",
          "description": "Whether to use a direct multiclass formulation (True) or one-vs-rest (False).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When multiclass is True, penalty must be l1/l2 and loss must be squared_hinge or log.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "The penalty to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "l1/l2",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "l2",
          "constraint": true,
          "constraintInformation": "When multiclass is True, penalty must be l1/l2.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "permute",
          "label": "Permute",
          "description": "Whether to permute coordinates or not before cycling (only when selection='cyclic').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "selection",
          "label": "Selection",
          "description": "Strategy to use for selecting coordinates.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "cyclic",
                "uniform"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "cyclic",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "shrinking",
          "label": "Shrinking",
          "description": "Whether to activate shrinking or not.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "sigma",
          "label": "Sigma",
          "description": "Constant used in the line search sufficient decrease condition.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.01,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "termination",
          "label": "Termination",
          "description": "Stopping criterion to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "violation_sum",
                "violation_max"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "violation_sum",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance of the stopping criterion.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "warm_debiasing",
          "label": "Warm debiasing",
          "description": "Whether to warm-start the model or not when doing debiasing.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "multiclass",
          "target": "penalty",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1/l2"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "l1",
                    "l1/l2",
                    "l2"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "multiclass",
          "target": "loss",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "log",
                    "squared_hinge"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "modified_huber",
                    "squared_hinge",
                    "log",
                    "squared"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "cd_classifier",
        "modelDescription": "The Coordinate Descent Classifier is a machine learning algorithm designed to optimize linear classifiers through (block) coordinate descent methods. It is particularly useful for large-scale and sparse data sets.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Scalable to large data sets.",
          "Efficient handling of sparse data.",
          "Fine-grained control through various hyperparameters."
        ],
        "disadvantages": [
          "May be sensitive to feature scaling.",
          "Limited to linear decision boundaries.",
          "Requires careful tuning of hyperparameters."
        ],
        "prime": [],
        "displayName": "Coordinate Descent Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "svrg_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Weight of the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta",
          "label": "Eta",
          "description": "Step size for the gradient updates.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Kernel coefficient for rbf and poly kernels. Ignored by other kernels.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "squared_hinge",
                "log",
                "modified_huber",
                "smooth_hinge",
                "squared"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "smooth_hinge",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_inner",
          "label": "Number of inner samples",
          "description": "Number of inner samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance of the stopping criterion.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "svrg_classifier",
        "modelDescription": "The Stochastic Variance-reduced Gradient (SVRG) Classifier is designed for large-scale optimization and is particularly well-suited for problems with a lot of features.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Efficient for high-dimensional data.",
          "Reduces variance in the stochastic gradients, accelerating convergence.",
          "Well-suited for sparse data.",
          "Performs well in large-scale optimization scenarios."
        ],
        "disadvantages": [
          "Can be sensitive to hyperparameters like step size.",
          "Not as versatile for non-linear problems as some other methods.",
          "Requires more computational resources for maintaining and updating gradients."
        ],
        "prime": [],
        "displayName": "Stochastic Variance-reduced Gradient Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "lightning"
      }
    },
    {
      "name": "saga_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Amount of squared L2 regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "beta",
          "label": "Beta",
          "description": "Amount of regularization for the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta",
          "label": "Eta",
          "description": "Step size for the gradient updates.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "auto",
                "line-search"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "auto",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Gamma parameter in the 'smooth_hinge' loss (not used for other loss functions).",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "log",
                "squared_hinge",
                "smooth_hinge"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "smooth_hinge",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance of the stopping criterion.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "saga_classifier",
        "modelDescription": "Stochastic Average Gradient (SAGA) is an optimization algorithm frequently employed for large-scale machine learning tasks. It is especially useful for handling high-dimensional data and large datasets. SAGA is an extension of Stochastic Gradient Descent (SGD) and aims to merge the benefits of batch and stochastic optimization methods. While it is commonly used for linear classifiers like logistic regression, it can also be adapted for other types of models.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Scalability: SAGA is engineered to efficiently handle large datasets and scales well with the number of observations.",
          "Memory Efficiency: Unlike full-batch methods, SAGA allows for the optimization of the model without needing to store the entire dataset in memory, which is more memory-efficient.",
          "Fast Convergence: For convex optimization problems, SAGA generally converges faster than traditional batch methods or standard stochastic methods.",
          "Robustness: SAGA is less sensitive to initial learning rate settings and other hyperparameters compared to standard SGD.",
          "Parallelism: While the core algorithm is inherently sequential, some level of parallelism can be achieved through data distribution."
        ],
        "disadvantages": [
          "Non-Convexity: SAGA is primarily designed for convex optimization problems, and its performance may suffer when applied to non-convex problems.",
          "Tuning Required: Despite being less sensitive to hyperparameters than other optimization methods, some tuning is often still required for optimal performance.",
          "Warm Start Sensitivity: The algorithm's performance may vary depending on the initial conditions, particularly when a warm start is utilized.",
          "Stochastic Nature: While this is less of an issue for convex problems, the stochastic nature of the algorithm means that it may oscillate around the global minimum for non-convex problems.",
          "Implementation Complexity: SAGA is more challenging to implement than simpler optimization algorithms like batch gradient descent."
        ],
        "prime": [],
        "displayName": "Stochastic Averaged Gradient Ascent Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "sdca_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Amount of regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Gamma parameter in the 'smooth_hinge' loss (not used for other loss functions).",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "Ratio between the L1 and L2 regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "hinge",
                "squared_hinge",
                "smooth_hinge",
                "absolute",
                "squared"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "hinge",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance of the stopping criterion.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "sdca_classifier",
        "modelDescription": "The Stochastic Dual Coordinate Ascent (SDCA) Classifier is a linear classification model that utilizes the SDCA optimization algorithm. It is designed for large-scale learning scenarios and is efficient for high-dimensional sparse data.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Efficient on large datasets due to its incremental nature.",
          "Converges quickly for sparse data.",
          "Less sensitive to the choice of hyperparameters compared to some other optimization algorithms.",
          "Good for high-dimensional data."
        ],
        "disadvantages": [
          "Primarily suited for linear classification, limiting its applicability for complex, non-linear problems.",
          "The quality of the solution may depend on the initial conditions.",
          "Does not directly support probability estimates.",
          "May require careful feature scaling."
        ],
        "prime": [],
        "displayName": "Stochastic Dual Coordinate Ascent Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "adagrad_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Weight of the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta",
          "label": "Eta",
          "description": "Decrease factor for line-search procedure.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Gamma coefficient in the loss 'smooth_hinge'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "The L1 ratio parameter represents the trade-off between the L1 and L2 regularization terms in the objective function. A value of 0 indicates L2 regularization only, while a value of 1 indicates L1 regularization only. Values between 0 and 1 apply a mix of both L1 and L2 regularization, which can be advantageous for capturing different types of feature importance while preventing overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "hinge",
                "squared_hinge",
                "modified_huber",
                "log",
                "smooth_hinge",
                "perceptron",
                "squared"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "hinge",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_iter",
          "label": "Number of iterations",
          "description": "This parameter specifies the maximum number of iterations the optimization algorithm will run to converge to a solution. Each iteration involves a complete pass over the training data. Setting this to a low value may speed up training but could result in suboptimal performance. Conversely, a higher value may allow the model to converge to a better solution but at the cost of increased computational time.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shuffle",
          "label": "Shuffle",
          "description": "Whether to shuffle data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "adagrad_classifier",
        "modelDescription": "This estimator is designed to leverage the AdaGrad (Adaptive Gradient Algorithm) optimization technique for training linear classifiers. The model dynamically adjusts the learning rate for each feature during training, which makes it well-suited for datasets that are sparse or high-dimensional. It is designed to minimize convex loss functions and generally requires less hyperparameter tuning compared to some other optimization algorithms.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Adaptive Learning Rate for Each Feature: One of the primary benefits of using this model is its adaptive learning rate, which adjusts individually for each feature. This characteristic is particularly advantageous when dealing with sparse or imbalanced data, as it allows the model to focus more on the important features.",
          "Easier Hyperparameter Tuning: The adaptive learning rates mean that the model is generally less sensitive to the initial choice of learning rate, which makes the task of hyperparameter tuning simpler and potentially faster.",
          "Effective for Convex Problems: The AdaGrad algorithm is efficient at finding the global minimum when the problem is convex. This makes it suitable for a wide range of machine learning problems where the loss function is convex."
        ],
        "disadvantages": [
          "Learning Rate Decay Issues: One of the drawbacks of the AdaGrad algorithm is that the learning rate for each feature can decrease to a point where the model makes very little progress. This is especially problematic for non-convex problems, where it can prevent the model from reaching the global minimum.",
          "Memory Overheads: The model tracks the sum of squares of past gradients for each feature, which increases its memory consumption. This may not be ideal for systems with limited memory resources.",
          "Computation Overheads: Although the model adjusts the learning rate for each feature, this operation can be computationally expensive, particularly for high-dimensional data sets. This could be a bottleneck in terms of both speed and computational resources when working with large, high-dimensional data."
        ],
        "prime": [],
        "displayName": "Adaptive Gradient Classifier",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "catboost_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "fast",
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "allow_const_label",
          "label": "Allow const label",
          "description": "Use it to train models with datasets that have equal label values for all objects.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "auto_class_weights",
          "label": "Automatic class weights",
          "description": "Enables automatic class weights calculation. It may be useful for imbalanced datasets.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "Balanced",
                "SqrtBalanced"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "bagging_temperature",
          "label": "Bagging temperature",
          "description": "Defines the settings of the Bayesian bootstrap. It is used by default in classification and regression modes.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "depth",
          "label": "Depth",
          "description": "The depth of the tree.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 6,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "feature_border_type",
          "label": "Feature border type",
          "description": "The quantization mode for numerical features.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Uniform",
                "UniformAndQuantiles",
                "MinEntropy",
                "GreedyLogSum",
                "Median"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "GreedyLogSum",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "final_ctr_computation_mode",
          "label": "Final CTR computation mode",
          "description": "Final CTR computation mode.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Skip",
                "Default"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "Default",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fold_len_multiplier",
          "label": "Fold length multiplier",
          "description": "Coefficient for changing the length of folds.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "fold_permutation_block",
          "label": "Fold permutation block",
          "description": "Objects in the dataset are grouped in blocks before the random permutations. This parameter defines the size of the blocks. The smaller is the value, the slower is the training. Large values may result in quality degradation.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "has_time",
          "label": "Has time",
          "description": "Use the order of objects in the input data (do not perform random permutations during the Transforming categorical features to numerical features and Choosing the tree structure stages).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "iterations",
          "label": "Iterations",
          "description": "The number of iterations.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 1001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "l2_leaf_reg",
          "label": "L2 regularization coefficient",
          "description": "Coefficient at the L2 regularization term of the cost function.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 3.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_ctr_complexity",
          "label": "Maximum complexity",
          "description": "The maximum number of features that can be combined.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 7
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 4,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "model_size_reg",
          "label": "Model size regularization coefficient",
          "description": "This parameter influences the model size if training data has categorical features.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "nan_mode",
          "label": "NaN mode",
          "description": "The method for  processing missing values in the input dataset.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Forbidden",
                "Min",
                "Max"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "Min",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "od_type",
          "label": "Overfitting detector type",
          "description": "The type of the overfitting detector to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Iter",
                "IncToDec"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "IncToDec",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "od_wait",
          "label": "Overfitting detector wait",
          "description": "The number of iterations to continue the training after the iteration with the optimal metric value.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 31
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "random_strength",
          "label": "Random strength",
          "description": "The amount of randomness to use for scoring splits when the tree structure is selected. Use this parameter to avoid overfitting the model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "rsm",
          "label": "RSM",
          "description": "Random subspace method. The percentage of features to use at each split selection, when features are selected over again at random.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.01,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "catboost_classifier",
        "modelDescription": "The CatBoost Classifier is a gradient-boosting model specialized in handling categorical features through permutation-driven techniques. It uses ordered boosting to reduce overfitting and symmetric trees for faster execution. It is often compared favorably to XGBoost and LightGBM, particularly when dealing with categorical data.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "Handles categorical features well",
          "Reduced overfitting through ordered boosting",
          "Fast execution with symmetric trees",
          "Competitive performance compared to XGBoost and LightGBM",
          "Robust default settings"
        ],
        "disadvantages": [
          "Higher memory consumption",
          "Less interpretable than simpler models",
          "May require parameter tuning for optimal performance",
          "Can be slower to train on very large datasets"
        ],
        "prime": [],
        "displayName": "CatBoost Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "catboost"
      }
    },
    {
      "name": "xgboost_classifier",
      "mlTask": "classification",
      "incompatibleMetrics": [],
      "groups": [
        "fast",
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "booster",
          "label": "Booster",
          "description": "Specifies the core boosting algorithm, determining the type of base learners in the ensemble model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "dart",
                "gbtree"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gbtree",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bylevel",
          "label": "Column subsample ratio by level",
          "description": "Fraction of features randomly sampled for each level of the decision tree during construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bynode",
          "label": "Column subsample ratio by node",
          "description": "Fraction of features randomly sampled for each new node in the decision tree during construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bytree",
          "label": "Column subsample ratio by tree",
          "description": "Fraction of features randomly sampled for each tree during model construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Minimum reduction in loss function required to create a new tree split, controlling model complexity and preventing overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in updates to prevent overfitting, making the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.3,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_delta_step",
          "label": "Maximum delta step",
          "description": "Maximum allowed change for each leaf output in the tree, mitigating imbalanced data influence by limiting weight updates.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1000.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "Maximum depth of the tree. Nodes are expanded until all leaves are pure or contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_child_weight",
          "label": "Minimum child weight",
          "description": "Minimum number of training examples required in each tree node to allow further splitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "Number of trees built during the training process.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "num_parallel_tree",
          "label": "Number of parallel trees",
          "description": "Number of parallel trees constructed during each iteration, supporting boosted random forests.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "reg_alpha",
          "label": "Regularization alpha",
          "description": "Strength of L1 regularization term, penalizing absolute values of leaf node weights, promoting sparsity and reducing overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "reg_lambda",
          "label": "Regularization lambda",
          "description": "Strength of L2 regularization term, penalizing squared values of leaf node weights, encouraging smaller weights and reducing overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "scale_pos_weight",
          "label": "Scale weight of positive class",
          "description": "Balance of positive and negative weights in binary classification, useful for imbalanced classes. Consider: sum(negative instances) / sum(positive instances).",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 100.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "Fraction of training examples randomly sampled without replacement for each tree, reducing overfitting and improving generalization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tree_method",
          "label": "Tree method",
          "description": "Algorithm used to construct decision trees during the training process.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "exact",
                "hist",
                "approx",
                "gpu_hist"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "hist",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "xgboost_classifier",
        "modelDescription": "The XGBoost Classifier is a powerful and efficient gradient boosting model from the XGBoost library. It combines multiple weak learners, typically decision trees, to create a strong ensemble model. In each iteration, a new weak learner is added to the ensemble, focusing on correcting the errors made by the previous learners. Predictions from the ensemble model are given by a weighted sum of the predictions of the individual weak learners. XGBoost Classifier is known for its high performance, scalability, and ability to handle imbalanced datasets, making it a popular choice for a wide range of machine learning tasks.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires less feature engineering",
          "Feature importance can be found out",
          "It is robust to outliers",
          "It performs well on large sized datasets",
          "It is computational fast"
        ],
        "disadvantages": [
          "It has the problem of overfitting",
          "It is harder to tune as there are too many hyperparameters"
        ],
        "prime": [],
        "displayName": "XGBoost Classifier",
        "supports": {
          "probabilities": true,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "xgboost"
      }
    }
  ]
}
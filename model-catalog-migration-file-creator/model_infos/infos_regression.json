{
  "models": [
    {
      "name": "ard_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha_1",
          "label": "Alpha 1",
          "description": "Shape parameter for the Gamma distribution prior over the alpha parameter, which influences the strength of the regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha_2",
          "label": "Alpha 2",
          "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter, which affects the distribution's shape and scale.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Indicates whether to calculate the intercept for this model. If set to False, the data is expected to be centered and no intercept will be used in calculations.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "lambda_1",
          "label": "Lambda 1",
          "description": "Shape parameter for the Gamma distribution prior over the lambda parameter, which influences the strength of the regularization for each feature's weight.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "lambda_2",
          "label": "Lambda 2",
          "description": "Inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter, which affects the distribution's shape and scale for each feature's weight.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_iter",
          "label": "Number of iterations",
          "description": "Maximum number of iterations for the model to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 300,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "threshold_lambda",
          "label": "Threshold lambda",
          "description": "Threshold for pruning weights with high precision from the computation, which can help in reducing model complexity.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10000.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 10000.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Controls the stopping criterion in iterative algorithms, specifying the minimum improvement in the objective function or loss between consecutive iterations required for the algorithm to continue training.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "ard_regressor",
        "modelDescription": "The Automatic Relevance Determination (ARD) model is a Bayesian linear regression model from the scikit-learn library that extends the traditional linear regression model by incorporating priors on the model parameters. It aims to estimate the relevance of each input feature by learning individual regularization parameters for each feature. This results in a form of automatic feature selection, as irrelevant or redundant features are assigned larger regularization parameters, effectively reducing their impact on the model's predictions. The ARD model uses an iterative optimization process to estimate both the model parameters and the hyperparameters associated with the priors. This Bayesian approach allows the model to quantify the uncertainty in its predictions, providing a measure of confidence alongside the predicted values. The ARD model is particularly useful for regression tasks with high-dimensional data, where the underlying structure of the data is unknown, and automatic feature selection or sparsity is desired.",
        "modelType": [
          "Linear Model",
          "Bayesian Model"
        ],
        "advantages": [
          "Automatically selects regularization parameters.",
          "Identifies the most relevant features for the regression task.",
          "Can handle multicollinearity in the input features.",
          "Reduces model complexity by pruning less important features."
        ],
        "disadvantages": [
          "Sensitive to the choice of hyperparameters.",
          "May require more iterations to converge compared to other linear regression models.",
          "Not suitable for very large datasets due to computational complexity."
        ],
        "prime": [],
        "displayName": "Automatic Relevance Determination Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "bayesian_ridge_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha_1",
          "label": "Alpha 1",
          "description": "Hyper-parameter : shape parameter for the Gamma distribution prior over the alpha parameter.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha_2",
          "label": "Alpha 2",
          "description": "Hyper-parameter : inverse scale parameter (rate parameter) for the Gamma distribution prior over the alpha parameter.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha_init",
          "label": "Alpha init",
          "description": "Initial value for alpha (precision of the noise). If not set, alpha_init is 1/Var(y).",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "lambda_1",
          "label": "Lambda 1",
          "description": "Hyper-parameter : shape parameter for the Gamma distribution prior over the lambda parameter.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "lambda_2",
          "label": "Lambda 2",
          "description": "Hyper-parameter : inverse scale parameter (rate parameter) for the Gamma distribution prior over the lambda parameter.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.3
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-06,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "lambda_init",
          "label": "Lambda init",
          "description": "Initial value for lambda (precision of the weights). If not set, lambda_init is 1.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter",
          "label": "Number of iterations",
          "description": "Maximum number of iterations.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 300,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "bayesian_ridge_regressor",
        "modelDescription": "Bayesian Ridge Regressor is a specialized type of Bayesian regression and uses a spherical Gaussian prior to fit the weights, which is also similar to the classical Ridge model.",
        "modelType": [
          "Linear Model",
          "Bayesian Model"
        ],
        "advantages": [
          "It adapts to the data at hand",
          "It can be used to include regularization parameters in the estimation procedure"
        ],
        "disadvantages": [
          "Inference of the model can be time consuming"
        ],
        "prime": [],
        "displayName": "Bayesian Ridge Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "decision_tree_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "fast",
        "explainable"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "absolute_error",
                "friedman_mse",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_error",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 10001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node expressed as a fraction of all training samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.15
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "splitter",
          "label": "Splitter",
          "description": "The strategy used to choose the split at each node.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "random",
                "best"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "best",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "decision_tree_regressor",
        "modelDescription": "Decision Trees Regressor predicts the value of a target variable by learning simple decision rules inferred from the data features.",
        "modelType": [
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires no pre-processing of data like the normalization and the scaling of data  Missing values in the data also do not affect"
        ],
        "disadvantages": [
          "A small change in the data can cause a large change",
          "It is computational expensive"
        ],
        "prime": [],
        "displayName": "Decision Tree Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": true,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "elastic_net_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "explainable"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "The Elastic-Net mixing parameter, with 0 <= l1_ratio <= 1.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 5001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "positive",
          "label": "Positive",
          "description": "When set to True, forces the coefficients to be positive.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "selection",
          "label": "Selection",
          "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "cyclic",
                "random"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "cyclic",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "elastic_net_regressor",
        "modelDescription": "The Elastic Net Regressor is a linear regression model that combines the strengths of both Lasso and Ridge regression techniques. By incorporating both L1 and L2 regularization terms, it provides a balanced approach to penalize coefficients, enabling the model to prevent overfitting while dealing effectively with correlated features. It is particularly useful when there are many correlated variables in the dataset, as it tends to distribute feature importance relatively equally among correlated variables while also performing feature selection.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Versatility in Handling Correlated Features: Elastic Net can effectively manage correlated features by blending L1 and L2 regularizations. This provides a balanced approach that tends to distribute the weight of importance among correlated variables.",
          "Prevents Overfitting While Enabling Feature Selection: Unlike Ridge regression, which can't set coefficients to zero, or Lasso, which can be inconsistent in high-dimensional spaces, Elastic Net brings the best of both worlds. It helps to prevent overfitting and, at the same time, can shrink less important features' coefficients to zero, performing automatic feature selection.",
          "Stability and Uniqueness: Elastic Net provides model stability under conditions where Lasso would produce multiple solutions due to highly correlated predictors. The Ridge component of Elastic Net ensures that a unique solution exists, which aids in model interpretability and consistency."
        ],
        "disadvantages": [
          "Computational Complexity: Elastic Net requires the tuning of two hyperparameters, which increases computational time and complexity. This can make grid search or other hyperparameter tuning methods more time-consuming compared to simpler models.",
          "Reduced Interpretability: While still more interpretable than many non-linear models, the inclusion of both L1 and L2 regularizations makes Elastic Net somewhat harder to interpret than standard Linear Regression.",
          "Sensitivity to Scaling: Elastic Net is sensitive to the scale of input features. Feature scaling is usually required to ensure that the regularization treats all features equally, adding an extra preprocessing step."
        ],
        "prime": [],
        "displayName": "Elastic Net Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "gradient_boosting_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.9,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "Complexity parameter used for Minimal Cost-Complexity Pruning. The subtree with the largest cost complexity that is smaller than ccp_alpha will be chosen. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function to measure the quality of a split.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "friedman_mse",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "friedman_mse",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "quantile",
                "absolute_error",
                "huber",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_error",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity. If None then unlimited number of leaf nodes.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 10001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "A node will be split if this split induces a decrease of the impurity greater than or equal to this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node expressed as a fraction of all training samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node expressed as a fraction of all training samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.5
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of base estimators in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "Subsample ratio of the training instances. Setting it to 0.5 means that XGBoost would randomly sample half of the training data prior to growing trees. and this will prevent overfitting. Subsampling will occur once in every boosting iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "gradient_boosting_regressor",
        "modelDescription": "Gradient Boosting Regressor builds an additive model in a forward stage-wise fashion; it allows for the optimization of arbitrary differentiable loss functions. In each stage, n_classes_ regression trees are fitted on the negative gradient of the binomial or multinomial deviance loss function.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires no pre-processing of data like the normalization and the scaling of data"
        ],
        "disadvantages": [
          "It is sensitive to outliers",
          "It has the problem of overfitting",
          "It is computationally expensive"
        ],
        "prime": [],
        "displayName": "Gradient Boosting Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "hist_gradient_boosting_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": true,
      "hyperParameters": [
        {
          "name": "l2_regularization",
          "label": "L2 regularization",
          "description": "The L2 regularization parameter. Use 0 for no regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "absolute_error",
                "poisson",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "squared_error",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_bins",
          "label": "Maximum bins",
          "description": "The maximum number of bins to use for non-missing values.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 256
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 255,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 50,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "Grow a tree with max_leaf_nodes in best-first fashion. Best nodes are defined as relative reduction in impurity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 31,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required to be at a leaf node.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 51
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 20,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-07,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "hist_gradient_boosting_regressor",
        "modelDescription": "Histogram-based Gradient Boosting Regressor is much faster than the Gradient Boosting Regressor for big datasets (n_samples >= 10 000). It has native support for missing values (NaNs). During training, the tree grower learns at each split point whether samples with missing values should go to the left or right child, based on the potential gain. When predicting, samples with missing values are assigned to the left or right child consequently.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires no pre-processing of data like the normalization and the scaling of data"
        ],
        "disadvantages": [
          "It is sensitive to outliers",
          "It has the problem of overfitting",
          "It is computationally expensive"
        ],
        "prime": [],
        "displayName": "Histogram-based Gradient Boosting Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "huber_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Value for numerical stability in adam. Only used when solver='adam'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1.01,
                  "upper": 3.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.35,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-05,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1e-05,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "huber_regressor",
        "modelDescription": "Huber Regressor is a linear model optimizing the squared loss and the absolute loss for the samples controlled by the threshold.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "It is robust to outliers"
        ],
        "disadvantages": [
          "It has problems with accuracy efficiency and stability"
        ],
        "prime": [],
        "displayName": "Huber Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "lasso_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the L1 term, controlling regularization strength. ",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 5001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "positive",
          "label": "Positive",
          "description": "When set to True, forces the coefficients to be positive.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "selection",
          "label": "Selection",
          "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "cyclic",
                "random"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "cyclic",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "lasso_regressor",
        "modelDescription": "The Lasso Regressor is a linear regression model that employs L1 regularization to add a penalty term to the loss function, which is proportional to the absolute value of the coefficients. This form of regularization encourages sparsity by forcing some coefficients to be exactly zero, effectively performing feature selection. Lasso is particularly useful when you suspect that many features are irrelevant or redundant, and you want a model that is easier to interpret.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Feature Selection: One of the key advantages of Lasso Regression is its ability to perform automatic feature selection. By forcing some coefficient estimates to be exactly zero, it provides a model that involves only a subset of the features, making the model easier to interpret and generalize.",
          "Prevention of Overfitting: Similar to Ridge and Elastic Net, Lasso also adds a penalty term to the loss function, discouraging overly complex models and thus helping to prevent overfitting.",
          "Works Well with High-Dimensional Data: Lasso Regression can provide good performance even when the number of features is greater than the number of samples, especially when only a subset of the features is relevant for prediction."
        ],
        "disadvantages": [
          "Stability Issues: Lasso can be unstable in cases where predictors are highly correlated. In such cases, it may arbitrarily choose one feature over another, which may vary with slight changes in the data.",
          "Hyperparameter Tuning: Just like Ridge and Elastic Net, Lasso also requires the tuning of a regularization strength hyperparameter, which can add to the complexity and computational time needed for model development.",
          "Limitation in Model Complexity: By zeroing out some of the coefficients, Lasso may produce a model that is too simplistic to capture the underlying patterns in the data, especially if the true relationship requires inclusion of all features."
        ],
        "prime": [],
        "displayName": "Lasso Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "linear_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "fast",
        "explainable"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Determines whether to include an intercept term in the linear regression model. If set to True, the model will calculate the intercept; if set to False, the model assumes that the data is centered and will not use an intercept in calculations.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "linear_regressor",
        "modelDescription": "The Linear Regressor is a fundamental statistical model that aims to establish a linear relationship between a set of input features and a continuous output variable. It is simple, interpretable, and computationally efficient, making it a good baseline model for many predictive tasks. The method seeks to fit a linear equation to observed data by minimizing the sum of the squared differences between the observed outcomes and the outcomes predicted by the model.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Interpretability: One of the main advantages of Linear Regression is its high interpretability. The coefficients of the model directly indicate the impact of each feature on the target variable, making it easy to explain the model's decisions.",
          "Low Computational Cost: Linear Regression is computationally inexpensive to train and predict, making it highly scalable for datasets with a large number of samples and features.",
          "Fast to Implement and Train: Due to its simplicity and the availability of analytical solutions, a Linear Regressor can be quickly implemented and trained, serving as a useful baseline model in many machine learning projects."
        ],
        "disadvantages": [
          "Prone to Overfitting with High-Dimensional Data: In cases where the number of features is greater than the number of observations, or when features are highly correlated, Linear Regression is susceptible to overfitting.",
          "Assumes Linear Relationship: Linear Regression assumes that the relationship between the features and the target variable is linear. This assumption may not hold for complex, real-world data sets where relationships can be non-linear.",
          "Sensitive to Outliers: The model is sensitive to outliers in the data, which can disproportionately affect the slope of the regression line and, consequently, the predictions."
        ],
        "prime": [],
        "displayName": "Linear Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "linearsvr_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 25.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "dual",
          "label": "Dual",
          "description": "Select the algorithm to either solve the dual or primal optimization problem. Prefer dual=False when n_samples > n_features.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When dual is False, loss must be squared_epsilon_insensitive.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Value for numerical stability in adam. Only used when solver='adam'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "intercept_scaling",
          "label": "Intercept scaling",
          "description": "Useful only when the solver 'liblinear' is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \u201csynthetic\u201d feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Specifies the loss function. The epsilon-insensitive loss (standard SVR) is the L1 loss, while the squared epsilon-insensitive loss (squared_epsilon_insensitive) is the L2 loss.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "epsilon_insensitive",
                "squared_epsilon_insensitive"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "epsilon_insensitive",
          "constraint": true,
          "constraintInformation": "When dual is False, loss must be squared_epsilon_insensitive.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 500,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "dual",
          "target": "loss",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "squared_epsilon_insensitive"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "epsilon_insensitive",
                    "squared_epsilon_insensitive"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "linearsvr_regressor",
        "modelDescription": "Linear Support Vector Machine Regressor is similar to Support Vector Machine Regressor with the linear kernel but has more flexibility in the choice of penalties and loss functions.",
        "modelType": [
          "Kernel Model",
          "Support Vector Machine Model"
        ],
        "advantages": [
          "It performs well in higher dimension spaces",
          "It is robust to outliers"
        ],
        "disadvantages": [
          "It is computationally expensive",
          "It is tricky in selecting the appropriate kernel function"
        ],
        "prime": [],
        "displayName": "Linear Support Vector Machine Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "mean_dummy_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "mean_dummy_regressor",
        "modelDescription": "The mean dummy regressor always predicts the mean of the training set.",
        "modelType": [
          "Baseline Model"
        ],
        "advantages": [
          "Easily explainable.",
          "Fast to train.",
          "Provides a baseline with which to compare other models."
        ],
        "disadvantages": [
          "Ignores all feature information."
        ],
        "prime": [],
        "displayName": "Mean Dummy Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "median_dummy_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "median_dummy_regressor",
        "modelDescription": "The median dummy regressor always predicts the median of the training set.",
        "modelType": [
          "Baseline Model"
        ],
        "advantages": [
          "Easily explainable.",
          "Fast to train.",
          "Provides a baseline with which to compare other models."
        ],
        "disadvantages": [
          "Ignores all feature information."
        ],
        "prime": [],
        "displayName": "Median Dummy Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "passive_aggressive_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Controls the inverse of regularization strength, with smaller values resulting in stronger regularization. Regularization helps prevent overfitting by penalizing large weights.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "early_stopping",
          "label": "Early stopping",
          "description": "Determines if early stopping should be used to halt training when the validation score is not improving, preventing overfitting and reducing training time.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Determines the threshold for the loss function, below which the model will not be updated. This balances the model's sensitivity to small errors and its robustness to noise.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Indicates if an intercept should be calculated for the model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Specifies the loss function to be optimized during training.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "epsilon_insensitive",
                "squared_epsilon_insensitive"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "epsilon_insensitive",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Sets the maximum number of iterations for the solver to converge, controlling the maximum training time.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Defines the maximum number of epochs without improvement in the validation score before stopping. Only effective when the solver is 'sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shuffle",
          "label": "Shuffle",
          "description": "Determines if samples should be shuffled in each iteration, which can help avoid getting stuck in local minima.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Controls the stopping criterion in iterative algorithms, specifying the minimum improvement in the objective function or loss between consecutive iterations required for the algorithm to continue training.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "Specifies the proportion of training data to be set aside as a validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "passive_aggressive_regressor",
        "modelDescription": "The Passive Aggressive Regressor is a linear model from the scikit-learn library. It is an online learning algorithm particularly suitable for large-scale data and streaming data scenarios where the model is incrementally updated with new data points. The algorithm derives its name from its approach to updating the model's weights: it is \"passive\" when the current model's prediction error is within a specified margin (controlled by the epsilon parameter), and \"aggressive\" when the prediction error exceeds this margin. The aggressiveness of the weight updates is controlled by a regularization parameter, which balances the trade-off between model stability and adaptability to new data. The Passive Aggressive Regressor is computationally efficient and can handle high-dimensional feature spaces, making it a valuable choice for various regression tasks, such as predicting numerical values in time-series data, forecasting sales, or estimating user ratings in recommendation systems.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Efficient for large-scale learning tasks",
          "Suitable for online learning and streaming data",
          "Can handle high-dimensional data",
          "Supports early stopping to prevent overfitting"
        ],
        "disadvantages": [
          "Sensitive to feature scaling",
          "Requires tuning of hyperparameters",
          "May not perform well on small datasets"
        ],
        "prime": [],
        "displayName": "Passive Aggressive Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "random_forest_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "bootstrap",
          "label": "Bootstrap",
          "description": "Indicates if bootstrap samples are used when building trees. If set to False, the entire dataset is used to build each tree, which may lead to overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When oob_score is True, bootstrap must be True. When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "The complexity parameter for Minimal Cost-Complexity Pruning, which helps prevent overfitting by pruning the tree. Larger values of alpha result in more aggressive pruning. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function used to measure the quality of a split in a decision tree.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "absolute_error",
                "poisson",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_error",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth allowed for each tree, which helps prevent overfitting by limiting complexity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "Specifies the maximum number of features to consider when making a split in each decision tree, introducing randomness and diversity among the trees to improve the model's generalization ability. ",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "The maximum number of leaf nodes allowed in each tree, grown in a best-first fashion. Limits the number of leaf nodes in each decision tree, controlling the tree's complexity and helping to prevent overfitting.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_samples",
          "label": "Maximum samples",
          "description": "The number of samples randomly drawn from the input data to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": true,
          "constraintInformation": "When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "The minimum decrease in impurity required for a node to be split. Helps prevent overfitting by controlling tree growth.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required for a node to be considered a leaf. This parameter helps prevent overfitting by ensuring that leaves have a sufficient number of samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node, which helps control the growth of the tree and prevent overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the total sample weights required for a node to be considered a leaf. By default, all samples have equal weight.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.01
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of decision trees in the ensemble, which affects the model's performance and complexity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "bootstrap",
          "target": "max_samples",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0001,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "random_forest_regressor",
        "modelDescription": "The Random Forest Regressor is a versatile and powerful ensemble learning method from the scikit-learn library. It works by constructing multiple decision trees during training and outputting the mean prediction of the individual trees. This model is particularly effective for handling large datasets with high dimensionality and can automatically learn feature interactions.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "Effective for large datasets and high-dimensional features",
          "Automatically learns feature interactions",
          "Reduces overfitting compared to single decision trees",
          "Provides feature importance scores",
          "Can handle missing data and requires minimal data preprocessing"
        ],
        "disadvantages": [
          "Can be computationally expensive due to the large number of trees",
          "Less interpretable than single decision trees",
          "Slower prediction time compared to some other models",
          "May not perform well on very small datasets or with very noisy data"
        ],
        "prime": [],
        "displayName": "Random Forest Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "ridge_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the L2 term, controlling regularization strength.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 5001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "positive",
          "label": "Positive",
          "description": "When set to True, forces the coefficients to be positive.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "ridge_regressor",
        "modelDescription": "The Ridge Regressor is a type of linear regression model that incorporates L2 regularization to penalize large coefficients in the predictive variables. By adding a squared magnitude term of the coefficients in the loss function, Ridge regression discourages overly complex models, thereby reducing overfitting. It is particularly useful in scenarios where the number of features is large compared to the number of observations or when features are correlated, which can lead to multicollinearity issues in standard linear regression.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Prevention of Overfitting: Ridge Regression helps prevent overfitting by adding a penalty term to the loss function, encouraging the model to keep the weight of each feature as small as possible. This makes it more robust when faced with irrelevant or highly correlated features.",
          "Stable Solutions in High-Dimensional Space: Ridge Regression performs well even when the number of features is greater than the number of observations, providing a stable solution where ordinary least squares would fail.",
          "Handles Multicollinearity: Ridge Regression deals effectively with multicollinearity (correlation between predictor variables) by distributing the coefficients among them. This makes it useful in applications where features are correlated, as it provides a more stable and robust estimate."
        ],
        "disadvantages": [
          "No Feature Selection: Unlike methods such as Lasso or Elastic Net, Ridge Regression does not set any coefficients to zero, making all features part of the final model. This can make the model less interpretable when there are many irrelevant features.",
          "Requires Hyperparameter Tuning: The strength of the regularization is controlled by a hyperparameter that needs to be tuned, adding to the complexity and computational cost of model development.",
          "Sensitive to Feature Scaling: Just like Elastic Net, Ridge Regression is sensitive to the scale of input features. Therefore, feature scaling is often necessary as a preprocessing step to ensure that all features are treated equally by the regularization term."
        ],
        "prime": [],
        "displayName": "Ridge Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "sgd_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "average",
          "label": "Average",
          "description": "When set to True, computes the averaged SGD weights accross all updates and stores the result in the coef_ attribute.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "early_stopping",
          "label": "Early stopping",
          "description": "Whether to use early stopping to terminate training when validation score is not improving.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Value for numerical stability in adam. Only used when solver='adam'.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta0",
          "label": "Eta0",
          "description": "The initial learning rate for the 'constant', 'invscaling' or 'adaptive' schedules.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.01,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "The Elastic-Net mixing parameter, with 0 <= l1_ratio <= 1.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.15,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in update to prevents overfitting. After each boosting step, we can directly get the weights of new features, and eta shrinks the feature weights to make the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "optimal",
                "invscaling",
                "adaptive",
                "constant"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "invscaling",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "loss",
          "label": "Loss",
          "description": "Loss function to be optimized.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "epsilon_insensitive",
                "huber",
                "squared_epsilon_insensitive",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "squared_error",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 2001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "n_iter_no_change",
          "label": "Maximum number of iterations with no change",
          "description": "Maximum number of epochs to not meet tol improvement. Only effective when solver='sgd' or 'adam'.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Penalty",
          "description": "The penalty (aka regularization term) to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "elasticnet",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l2",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "power_t",
          "label": "Power t",
          "description": "The exponent for inverse scaling learning rate.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 50.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.25,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "shuffle",
          "label": "Shuffle",
          "description": "Whether to shuffle samples in each iteration.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "validation_fraction",
          "label": "Validation fraction",
          "description": "The proportion of training data to set aside as validation set for early stopping.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.9999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "sgd_regressor",
        "modelDescription": "Stochastic Gradient Descent Regressor is a linear regression model with stochastic gradient descent (SGD) training. The gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "It is computationally efficient",
          "It has fast convergence for larger datasets"
        ],
        "disadvantages": [
          "It is not stable"
        ],
        "prime": [],
        "displayName": "Stochastic Gradient Descent Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "svr_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": true,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of the regularization strength. Controls the trade-off between achieving a low training error and a low testing error. A smaller value creates a wider margin, which may result in more training errors but better generalization to the test data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "coef0",
          "label": "Coefficient 0",
          "description": "Affects the shape of the decision boundary in 'poly' and 'sigmoid' kernels. It represents the independent term in the kernel function.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "degree",
          "label": "Degree",
          "description": "Specifies the degree of the polynomial kernel function ('poly'). Higher degrees result in more complex decision boundaries. This parameter is ignored by all other kernels.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 6
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 3,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Defines the margin of tolerance within which no penalty is given to errors. It determines the width of the epsilon-insensitive zone used to fit the training data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 2.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "kernel",
          "label": "Kernel",
          "description": "Determines the kernel function used in the algorithm. The kernel function transforms the input data into a higher-dimensional space where a linear function is fitted.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "poly",
                "sigmoid",
                "rbf"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "rbf",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Sets the maximum number of iterations for the solver to converge. Early stopping may result in a suboptimal solution.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 1001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shrinking",
          "label": "Shrinking",
          "description": "Indicates whether to use the shrinking heuristic, which is a technique used to remove some of the constraints in the optimization problem to speed up training.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Specifies the tolerance for stopping criterion. The solver stops when the change in the residual is smaller than this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "svr_regressor",
        "modelDescription": "The SVR Regressor is a Support Vector Regression model from the scikit-learn library. It is an extension of the Support Vector Machine (SVM) algorithm for regression tasks. The model aims to find a function that approximates the relationship between input features and target values with a specified tolerance (epsilon). It uses different kernel functions to transform the input data into a higher-dimensional space, where a linear function is fitted to minimize the error between predicted and actual target values.",
        "modelType": [
          "Kernel Model",
          "Support Vector Machine Model"
        ],
        "advantages": [
          "Effective in high-dimensional spaces.",
          "Supports different kernel functions for versatile modeling.",
          "Robust against overfitting, especially when using a high-dimensional feature space."
        ],
        "disadvantages": [
          "Can be slow to train on large datasets.",
          "Requires careful selection of kernel and hyperparameters."
        ],
        "prime": [],
        "displayName": "SVR Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "base"
      }
    },
    {
      "name": "nlp_sequence_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "epochs",
          "label": "Epochs",
          "description": "Number of epochs to train the model.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 2,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning Rate",
          "description": "Learning rate for the optimizer.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 1e-06,
                  "upper": 0.0001
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 5e-05,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_length",
          "label": "Max Length",
          "description": "Maximum length of the input sequence.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 32,
                  "stop": 513
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 64,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "model",
          "label": "Transformer Model Name",
          "description": "Name of the transformer model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "albert-base-v2",
                "roberta-base",
                "bert-base-cased",
                "distilbert-base-uncased",
                "bert-base-uncased",
                "distilbert-base-cased"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "bert-base-cased",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "nlp_sequence_regressor",
        "modelDescription": "An NLP sequence regressor is a pretrained machine learning model that can be fine tuned to predict continuous values from sequences of text.",
        "modelType": [
          "Deep Learning Model"
        ],
        "advantages": [
          "Easy to use",
          "High accuracy"
        ],
        "disadvantages": [
          "Slow training"
        ],
        "prime": [
          "model"
        ],
        "displayName": "NLP Sequence Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "huggingface"
      }
    },
    {
      "name": "intelex_elastic_net_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Constant that multiplies the penalty terms.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (i.e. data is expected to be centered).",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "l1_ratio",
          "label": "L1 ratio",
          "description": "The Elastic-Net mixing parameter, with 0 <= l1_ratio <= 1.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "    Maximum number of iterations taken for the solvers to converge.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 5001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "positive",
          "label": "Positive",
          "description": "When set to True, forces the coefficients to be positive.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "selection",
          "label": "Selection",
          "description": "If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "cyclic",
                "random"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "cyclic",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Maximum norm of the residual.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "intelex_elastic_net_regressor",
        "modelDescription": "The Elastic Net Regressor is a linear regression model that combines the strengths of both Lasso and Ridge regression techniques. By incorporating both L1 and L2 regularization terms, it provides a balanced approach to penalize coefficients, enabling the model to prevent overfitting while dealing effectively with correlated features. It is particularly useful when there are many correlated variables in the dataset, as it tends to distribute feature importance relatively equally among correlated variables while also performing feature selection.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Versatility in Handling Correlated Features: Elastic Net can effectively manage correlated features by blending L1 and L2 regularizations. This provides a balanced approach that tends to distribute the weight of importance among correlated variables.",
          "Prevents Overfitting While Enabling Feature Selection: Unlike Ridge regression, which can't set coefficients to zero, or Lasso, which can be inconsistent in high-dimensional spaces, Elastic Net brings the best of both worlds. It helps to prevent overfitting and, at the same time, can shrink less important features' coefficients to zero, performing automatic feature selection.",
          "Stability and Uniqueness: Elastic Net provides model stability under conditions where Lasso would produce multiple solutions due to highly correlated predictors. The Ridge component of Elastic Net ensures that a unique solution exists, which aids in model interpretability and consistency."
        ],
        "disadvantages": [
          "Computational Complexity: Elastic Net requires the tuning of two hyperparameters, which increases computational time and complexity. This can make grid search or other hyperparameter tuning methods more time-consuming compared to simpler models.",
          "Reduced Interpretability: While still more interpretable than many non-linear models, the inclusion of both L1 and L2 regularizations makes Elastic Net somewhat harder to interpret than standard Linear Regression.",
          "Sensitivity to Scaling: Elastic Net is sensitive to the scale of input features. Feature scaling is usually required to ensure that the regularization treats all features equally, adding an extra preprocessing step."
        ],
        "prime": [],
        "displayName": "Intelex Elastic Net Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "intelex_linear_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "fit_intercept",
          "label": "Calculate Intercept",
          "description": "Determines whether to include an intercept term in the linear regression model. If set to True, the model will calculate the intercept; if set to False, the model assumes that the data is centered and will not use an intercept in calculations.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "intelex_linear_regressor",
        "modelDescription": "The Linear Regressor is a fundamental statistical model that aims to establish a linear relationship between a set of input features and a continuous output variable. It is simple, interpretable, and computationally efficient, making it a good baseline model for many predictive tasks. The method seeks to fit a linear equation to observed data by minimizing the sum of the squared differences between the observed outcomes and the outcomes predicted by the model.",
        "modelType": [
          "Linear Model"
        ],
        "advantages": [
          "Interpretability: One of the main advantages of Linear Regression is its high interpretability. The coefficients of the model directly indicate the impact of each feature on the target variable, making it easy to explain the model's decisions.",
          "Low Computational Cost: Linear Regression is computationally inexpensive to train and predict, making it highly scalable for datasets with a large number of samples and features.",
          "Fast to Implement and Train: Due to its simplicity and the availability of analytical solutions, a Linear Regressor can be quickly implemented and trained, serving as a useful baseline model in many machine learning projects."
        ],
        "disadvantages": [
          "Prone to Overfitting with High-Dimensional Data: In cases where the number of features is greater than the number of observations, or when features are highly correlated, Linear Regression is susceptible to overfitting.",
          "Assumes Linear Relationship: Linear Regression assumes that the relationship between the features and the target variable is linear. This assumption may not hold for complex, real-world data sets where relationships can be non-linear.",
          "Sensitive to Outliers: The model is sensitive to outliers in the data, which can disproportionately affect the slope of the regression line and, consequently, the predictions."
        ],
        "prime": [],
        "displayName": "Intelex Linear Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "intelex_random_forest_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "bootstrap",
          "label": "Bootstrap",
          "description": "Indicates if bootstrap samples are used when building trees. If set to False, the entire dataset is used to build each tree, which may lead to overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": true,
          "constraintInformation": "When oob_score is True, bootstrap must be True. When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "ccp_alpha",
          "label": "Cost-Complexity Pruning alpha",
          "description": "The complexity parameter for Minimal Cost-Complexity Pruning, which helps prevent overfitting by pruning the tree. Larger values of alpha result in more aggressive pruning. By default, no pruning is performed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "criterion",
          "label": "Criterion",
          "description": "The function used to measure the quality of a split in a decision tree.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "absolute_error",
                "poisson",
                "squared_error"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "squared_error",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth allowed for each tree, which helps prevent overfitting by limiting complexity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_features",
          "label": "Maximum features",
          "description": "Specifies the maximum number of features to consider when making a split in each decision tree, introducing randomness and diversity among the trees to improve the model's generalization ability. ",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "log2",
                "sqrt"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_leaf_nodes",
          "label": "Maximum number of nodes",
          "description": "The maximum number of leaf nodes allowed in each tree, grown in a best-first fashion. Limits the number of leaf nodes in each decision tree, controlling the tree's complexity and helping to prevent overfitting.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 1025
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1024,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_samples",
          "label": "Maximum samples",
          "description": "The number of samples randomly drawn from the input data to train each base estimator.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": true,
          "constraintInformation": "When bootstrap is False, max_samples must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_impurity_decrease",
          "label": "Minimum impurity decrease",
          "description": "The minimum decrease in impurity required for a node to be split. Helps prevent overfitting by controlling tree growth.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.1
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_leaf",
          "label": "Minimum samples per leaf",
          "description": "The minimum number of samples required for a node to be considered a leaf. This parameter helps prevent overfitting by ensuring that leaves have a sufficient number of samples.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 0.05
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_samples_split",
          "label": "Minimum sample split",
          "description": "The minimum number of samples required to split an internal node, which helps control the growth of the tree and prevent overfitting.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 21
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 2,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_weight_fraction_leaf",
          "label": "Minimum weighted sum per leaf",
          "description": "The minimum weighted fraction of the total sample weights required for a node to be considered a leaf. By default, all samples have equal weight.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.01
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of decision trees in the ensemble, which affects the model's performance and complexity.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "bootstrap",
          "target": "max_samples",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": []
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0001,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "intelex_random_forest_regressor",
        "modelDescription": "The Random Forest Regressor, powered by Intel oneDAL, is a versatile and powerful ensemble learning method. It works by constructing multiple decision trees during training and outputting the mean prediction of the individual trees. This model is particularly effective for handling large datasets with high dimensionality and can automatically learn feature interactions. Intel's oneDAL significantly improves the performance of this model, making it suitable for applications that demand high performance.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "Effective for large datasets and high-dimensional features",
          "Automatically learns feature interactions",
          "Reduces overfitting compared to single decision trees",
          "Provides feature importance scores",
          "Can handle missing data and requires minimal data preprocessing",
          "Leverages Intel oneDAL for high-performance and scalability on Intel hardware"
        ],
        "disadvantages": [
          "Can be computationally expensive due to the large number of trees",
          "Less interpretable than single decision trees",
          "Slower prediction time compared to some other models",
          "May not perform well on very small datasets or with very noisy data"
        ],
        "prime": [],
        "displayName": "Intelex Random Forest Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "intelex_svr_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Inverse of the regularization strength. Controls the trade-off between achieving a low training error and a low testing error. A smaller value creates a wider margin, which may result in more training errors but better generalization to the test data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "coef0",
          "label": "Coefficient 0",
          "description": "Affects the shape of the decision boundary in 'poly' and 'sigmoid' kernels. It represents the independent term in the kernel function.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "degree",
          "label": "Degree",
          "description": "Specifies the degree of the polynomial kernel function ('poly'). Higher degrees result in more complex decision boundaries. This parameter is ignored by all other kernels.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 6
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 3,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "epsilon",
          "label": "Epsilon",
          "description": "Defines the margin of tolerance within which no penalty is given to errors. It determines the width of the epsilon-insensitive zone used to fit the training data.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 2.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "kernel",
          "label": "Kernel",
          "description": "Determines the kernel function used in the algorithm. The kernel function transforms the input data into a higher-dimensional space where a linear function is fitted.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "poly",
                "sigmoid",
                "rbf"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "rbf",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Sets the maximum number of iterations for the solver to converge. Early stopping may result in a suboptimal solution.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 1001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "shrinking",
          "label": "Shrinking",
          "description": "Indicates whether to use the shrinking heuristic, which is a technique used to remove some of the constraints in the optimization problem to speed up training.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Specifies the tolerance for stopping criterion. The solver stops when the change in the residual is smaller than this value.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "intelex_svr_regressor",
        "modelDescription": "The SVR Regressor is a Support Vector Regression model from the scikit-learn library. It is an extension of the Support Vector Machine (SVM) algorithm for regression tasks. The model aims to find a function that approximates the relationship between input features and target values with a specified tolerance (epsilon). It uses different kernel functions to transform the input data into a higher-dimensional space, where a linear function is fitted to minimize the error between predicted and actual target values.",
        "modelType": [
          "Kernel Model",
          "Support Vector Machine Model"
        ],
        "advantages": [
          "Effective in high-dimensional spaces.",
          "Supports different kernel functions for versatile modeling.",
          "Robust against overfitting, especially when using a high-dimensional feature space."
        ],
        "disadvantages": [
          "Can be slow to train on large datasets.",
          "Requires careful selection of kernel and hyperparameters."
        ],
        "prime": [],
        "displayName": "Intelex SVR Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "base",
        "dependencyGroup": "intelex"
      }
    },
    {
      "name": "feature_reduction_stacking_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "feature_reduction_stacking_regressor",
        "modelDescription": "A meta-regressor is fitted on the predictions of a number of base models, which may be reduced to a lower dimensional space. It is combined with the initial training data, which is reduced to a lower dimensional space.",
        "modelType": [
          "Ensemble Model"
        ],
        "advantages": [],
        "disadvantages": [],
        "prime": [],
        "displayName": "Feature Reduction Stacking Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "dynamic",
        "dependencyGroup": "stacking"
      }
    },
    {
      "name": "stacking_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "stacking_regressor",
        "modelDescription": "A meta-regressor is fitted on the predictions of a number of base models, which may be combined with the initial training data.",
        "modelType": [
          "Ensemble Model"
        ],
        "advantages": [],
        "disadvantages": [],
        "prime": [],
        "displayName": "Stacking Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "dynamic",
        "dependencyGroup": "stacking"
      }
    },
    {
      "name": "base_reduction_stacking_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [],
      "constraintEdges": [],
      "metadata": {
        "model": "base_reduction_stacking_regressor",
        "modelDescription": "A meta-regressor is fitted on the predictions of a number of base models and the base predictions space is reduced to a lower dimensional space. It may be combined with the initial training data.",
        "modelType": [
          "Ensemble Model"
        ],
        "advantages": [],
        "disadvantages": [],
        "prime": [],
        "displayName": "Base Reduction Stacking Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": false
        },
        "structure": "dynamic",
        "dependencyGroup": "stacking"
      }
    },
    {
      "name": "lightgbm_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "fast",
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "boosting_type",
          "label": "Boosting type",
          "description": "Specifies the type of boosting algorithm to use, which determines how the model combines weak learners to form a strong learner.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "dart",
                "goss",
                "gbdt",
                "rf"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gbdt",
          "constraint": true,
          "constraintInformation": "When boosting_type is rf, subsample must be in (0, 1), and subsample_freq must be greater than or equal to 1. When boosting_type is goss, subsample_freq must be smaller than or equal to 0.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bytree",
          "label": "Column subsample ratio by tree",
          "description": "The fraction of features to select for each tree, which helps in reducing overfitting and improving training speed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "The shrinkage factor applied to the weights of new features after each boosting step, which helps prevent overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.01,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "The maximum depth of each decision tree, which controls the complexity of the model and prevents overfitting.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_child_samples",
          "label": "Minimum childs per sample",
          "description": "The minimum number of samples required in a leaf node, which helps prevent overfitting by controlling tree growth.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 51
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 20,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_child_weight",
          "label": "Minimum child weight",
          "description": "The minimum sum of instance weights (hessian) required in a child node, which affects the tree structure and prevents overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.001,
                  "upper": 0.25
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "min_split_gain",
          "label": "Minimal gain to split",
          "description": "The minimum gain required to perform a split, which helps control the complexity of the model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 5.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "The number of decision trees in the ensemble, which determines the overall complexity and capacity of the model.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 201
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "num_leaves",
          "label": "Number of leaves",
          "description": "The maximum number of leaves in a single decision tree, which controls the complexity of the tree and affects the model's accuracy.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 31,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "reg_alpha",
          "label": "Regularization alpha",
          "description": "The L1 regularization term applied to the weights, which helps prevent overfitting by encouraging sparsity in the model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10000.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "reg_lambda",
          "label": "Regularization lambda",
          "description": "The L2 regularization term applied to the weights, which helps prevent overfitting by penalizing large weights.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10000.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "The fraction of training instances to use for each boosting iteration, which helps prevent overfitting and improves training speed.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.5,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": true,
          "constraintInformation": "When boosting_type is rf, subsample must be in (0, 1).",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "subsample_for_bin",
          "label": "Subsamples to construct bin",
          "description": "The number of samples used to construct discrete bins for continuous features, which affects the speed and memory usage of the model.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 100,
                  "stop": 1000001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 200000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "subsample_freq",
          "label": "Subsample frequency",
          "description": "The frequency at which subsampling occurs during the boosting process, which helps control overfitting and training speed.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 0,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 0,
          "constraint": true,
          "constraintInformation": "When boosting_type is rf, subsample_freq must be greater than or equal to 1. When boosting_type is goss, subsample_freq must be smaller than or equal to 0.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "boosting_type",
          "target": "subsample",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "rf"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": null,
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": false,
                      "lower": 0.1,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "goss"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": null,
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 1.0,
                      "upper": 1.0
                    }
                  ]
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "dart",
                    "gbdt"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": null,
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.1,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        },
        {
          "source": "boosting_type",
          "target": "subsample_freq",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "rf"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": [
                    {
                      "start": 1,
                      "stop": 11
                    }
                  ]
                },
                "categoricalSet": null,
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "goss"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": [
                    {
                      "start": 0,
                      "stop": 1
                    }
                  ]
                },
                "categoricalSet": null,
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "dart",
                    "gbdt"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": [
                    {
                      "start": 0,
                      "stop": 11
                    }
                  ]
                },
                "categoricalSet": null,
                "floatSet": null
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "lightgbm_regressor",
        "modelDescription": "The LightGBM Regressor is a gradient boosting framework based on decision trees from the LightGBM library. It uses a novel technique called Gradient-based One-Side Sampling (GOSS) to filter out the data instances for finding a split value, and Exclusive Feature Bundling (EFB) to reduce the number of features during training. This results in a faster training process and lower memory usage while maintaining high accuracy.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "Faster training speed and lower memory usage compared to other gradient boosting frameworks.",
          "High accuracy and good generalization performance.",
          "Supports parallel and GPU learning.",
          "Handles large-scale data and high-dimensional features well."
        ],
        "disadvantages": [
          "Requires careful tuning of hyperparameters for optimal performance.",
          "Less interpretable than simpler models like linear regression.",
          "Not as robust to noise and outliers as some other models."
        ],
        "prime": [],
        "displayName": "LightGBM Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "lightgbm"
      }
    },
    {
      "name": "fista_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Weight of the loss term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Weight of the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "eta",
          "label": "Eta",
          "description": "Decrease factor for line-search procedure.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 5.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 2.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_steps",
          "label": "Maximum number of steps",
          "description": "Maximum number of steps to use during the line search.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 30,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "l1/l2",
                "simplex",
                "tv1d"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l1",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "sigma",
          "label": "Eta",
          "description": "Constant used in the line search sufficient decrease condition.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1e-05,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "fista_regressor",
        "modelDescription": "An estimator that employs the Fast Iterative Shrinkage-Thresholding Algorithm (FISTA) for training linear regression models. Designed for rapid convergence, FISTA is particularly advantageous for tackling large-scale and high-dimensional problems. The algorithm promotes sparse solutions, making it memory-efficient. It is well-suited for convex optimization tasks and offers flexibility in terms of regularization techniques.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Rapid Convergence: FISTA is designed for fast convergence, making it highly suitable for large and high-dimensional datasets.",
          "Promotes Sparse Solutions: The algorithm encourages sparsity in the feature coefficients, which is advantageous in high-dimensional scenarios where feature selection is essential.",
          "Memory-Efficient: Unlike some other optimization algorithms, FISTA does not require the storage of large intermediate matrices, making it resource-efficient."
        ],
        "disadvantages": [
          "Hyperparameter Sensitivity: The performance of the FISTA Regressor can be sensitive to the choice of hyperparameters, requiring careful tuning for optimal results.",
          "Numerical Instabilities: Similar to its classifier counterpart, the FISTA Regressor may suffer from numerical instabilities, which could impact its performance and reliability."
        ],
        "prime": [],
        "displayName": "Fast Iterative Shrinkage/Thresholding Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "lightning"
      }
    },
    {
      "name": "cd_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "C",
          "label": "C",
          "description": "Weight of the loss term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "Cd",
          "label": "C when doing debiasing",
          "description": "Value of `C` when doing debiasing.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "alpha",
          "label": "Alpha",
          "description": "Weight of the penalty term.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "beta",
          "label": "Beta",
          "description": "Multiplicative constant used in the backtracking line search.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.5,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "debiasing",
          "label": "Debiasing",
          "description": "Whether to refit the model using l2 penalty (only useful if penalty='l1' or penalty='l1/l2').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_iter",
          "label": "Maximum number of iterations",
          "description": "Maximum number of iterations to perform.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 501
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 50,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_steps",
          "label": "Maximum number of steps",
          "description": "Maximum number of steps to use during the line search.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 30,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "penalty",
          "label": "Loss",
          "description": "The loss function to be used.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "l1",
                "l1/l2",
                "l2"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "l2",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "permute",
          "label": "Permute",
          "description": "Whether to permute coordinates or not before cycling (only when selection='cyclic').",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "selection",
          "label": "Selection",
          "description": "Strategy to use for selecting coordinates.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "cyclic",
                "uniform"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "cyclic",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "shrinking",
          "label": "Shrinking",
          "description": "Whether to activate shrinking or not.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": true,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "sigma",
          "label": "Sigma",
          "description": "Constant used in the line search sufficient decrease condition.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.01,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "termination",
          "label": "Termination",
          "description": "Stopping criterion to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "violation_sum",
                "violation_max"
              ]
            },
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": "violation_sum",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tol",
          "label": "Tolerance",
          "description": "Tolerance of the stopping criterion.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.001,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "warm_debiasing",
          "label": "Warm debiasing",
          "description": "Whether to warm-start the model or not when doing debiasing.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "cd_regressor",
        "modelDescription": "The Coordinate Descent Regressor is a machine learning algorithm designed to optimize linear regression models through (block) coordinate descent methods. It is particularly well-suited for large-scale and sparse datasets.",
        "modelType": [
          "Gradient Model"
        ],
        "advantages": [
          "Scalable to Large Datasets: The algorithm is designed to efficiently handle large volumes of data, making it suitable for applications with massive datasets.",
          "Efficient Handling of Sparse Data: The Coordinate Descent Regressor can effectively manage sparse datasets, optimizing computational resources and potentially improving model performance.",
          "Fine-Grained Control: The model offers various hyperparameters that provide fine-grained control over the optimization process, allowing for customized model tuning."
        ],
        "disadvantages": [
          "Sensitive to Feature Scaling: Similar to its classifier counterpart, the Coordinate Descent Regressor may also be sensitive to the scaling of features, requiring pre-processing steps.",
          "Limited to Linear Relationships: The model is primarily designed for linear regression tasks, making it less suitable for capturing complex, non-linear relationships in the data.",
          "Hyperparameter Tuning Required: The performance of the model may be highly dependent on the appropriate tuning of hyperparameters, adding to the complexity and time required for model development."
        ],
        "prime": [],
        "displayName": "Coordinate Descent Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "lightning"
      }
    },
    {
      "name": "catboost_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [
        "fast",
        "explainable",
        "advanced"
      ],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "allow_const_label",
          "label": "Allow const label",
          "description": "Allows training with datasets that have equal label values for all objects.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "approx_on_full_history",
          "label": "Approximation on full history",
          "description": "Determines whether approximated values are calculated using all preceding rows in the fold or only a fraction of them.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When boosting_type is Plain, approx_on_full_history must be False.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "bagging_temperature",
          "label": "Bagging temperature",
          "description": "Controls the intensity of Bayesian bagging, with higher values resulting in more aggressive bagging.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When bootstrap_type is Bayesian or Bernoulli, bagging_temperature must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "boost_from_average",
          "label": "Boost from average",
          "description": "Initializes approximated values with the best constant value for the specified loss function.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": true,
          "constraintInformation": "When boost_from_average is True, model_shrink_rate must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "boosting_type",
          "label": "Boosting type",
          "description": "Specifies the boosting scheme, either 'Ordered' for better quality or 'Plain' for classic gradient boosting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Ordered",
                "Plain",
                "None"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When boosting_type is Plain, approx_on_full_history must be False.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "bootstrap_type",
          "label": "Bootstrap type",
          "description": "Determines the method used for sampling the data during the training process to create a diverse ensemble of weak learners.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Bernoulli",
                "Bayesian",
                "MVS"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "MVS",
          "constraint": true,
          "constraintInformation": "When bootstrap_type is Bayesian or Bernoulli, bagging_temperature must be None. When bootstrap_type is Bayesian, subsample must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "counter_calc_method",
          "label": "Counter calc method",
          "description": "Specifies the method used for calculating counters (statistics-based encodings) for categorical features, which generates new features enabling better capture of the relationship between categorical features and the target variable.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "None",
                "Full",
                "SkipTest"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "depth",
          "label": "Depth",
          "description": "Sets the maximum depth of the decision trees in the ensemble.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 6,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "feature_border_type",
          "label": "Feature border type",
          "description": "Determines the quantization mode for numerical features.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Uniform",
                "UniformAndQuantiles",
                "MinEntropy",
                "GreedyLogSum",
                "Median"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "GreedyLogSum",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "fold_len_multiplier",
          "label": "Fold length multiplier",
          "description": "Adjusts the length of folds by a specified coefficient.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 2,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "fold_permutation_block",
          "label": "Fold permutation block",
          "description": "Sets the size of blocks for grouping objects in the dataset before random permutations.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 11
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "has_time",
          "label": "Has time",
          "description": "Uses the order of objects in the input data without performing random permutations during certain stages.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "False",
                "True"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": false,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "iterations",
          "label": "Iterations",
          "description": "Sets the number of iterations for the model.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 1001
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 1000,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "l2_leaf_reg",
          "label": "L2 regularization coefficient",
          "description": "Specifies the coefficient for the L2 regularization term of the cost function.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 3.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "leaf_estimation_backtracking",
          "label": "Leaf estimation backtracking",
          "description": "Determines the backtracking behavior when leaf_estimation_iterations is greater than 1.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "AnyImprovement",
                "No"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "AnyImprovement",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Sets the step size shrinkage to prevent overfitting during the boosting process.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "max_ctr_complexity",
          "label": "Maximum complexity",
          "description": "The maximum number of categorical features that can be combined to generate numerical features during the training process.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 7
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 4,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "model_shrink_rate",
          "label": "Model shrink rate",
          "description": "Enables model shrinkage at the start of each iteration, which reduces the influence of the most recently added weak learners and helps prevent overfitting.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 0.999
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When boost_from_average is True, model_shrink_rate must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "model_size_reg",
          "label": "Model size regularization coefficient",
          "description": "Influences the model size when training data contains categorical features.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "nan_mode",
          "label": "NaN mode",
          "description": "Specifies the method for processing missing values in the input dataset.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Forbidden",
                "Min",
                "Max"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "Min",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "od_type",
          "label": "Overfitting detector type",
          "description": "Sets the type of overfitting detector to use.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "Iter",
                "IncToDec"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "IncToDec",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "od_wait",
          "label": "Overfitting detector wait",
          "description": "Determines the number of iterations to continue training after the iteration with the optimal metric value.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 31
                }
              ]
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": []
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "random_strength",
          "label": "Random strength",
          "description": "Sets the amount of randomness used for scoring splits during tree structure selection to avoid overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "rsm",
          "label": "RSM",
          "description": "Specifies the percentage of features to use at each split selection with random subspace method.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.01,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": "None",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "score_function",
          "label": "Score function",
          "description": "Defines the score type used to select the next split during tree construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "L2",
                "Cosine"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "Cosine",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "Determines the fraction of the training dataset randomly sampled without replacement for training each weak learner, introducing diversity and reducing overfitting.",
          "domain": {
            "integerSet": {
              "ranges": []
            },
            "categoricalSet": {
              "categories": [
                "None"
              ]
            },
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.4,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": "None",
          "constraint": true,
          "constraintInformation": "When bootstrap_type is Bayesian, subsample must be None.",
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [
        {
          "source": "boost_from_average",
          "target": "model_shrink_rate",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "True"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0,
                      "upper": 0.999
                    }
                  ]
                }
              }
            }
          ]
        },
        {
          "source": "boosting_type",
          "target": "approx_on_full_history",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "None",
                    "Plain"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False"
                  ]
                },
                "floatSet": null
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "Ordered"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "False",
                    "True"
                  ]
                },
                "floatSet": null
              }
            }
          ]
        },
        {
          "source": "bootstrap_type",
          "target": "bagging_temperature",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "Bayesian"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "Bernoulli"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "MVS"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.0,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        },
        {
          "source": "bootstrap_type",
          "target": "subsample",
          "mapping": [
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "Bayesian"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": []
                }
              }
            },
            {
              "source": {
                "integerSet": null,
                "categoricalSet": {
                  "categories": [
                    "Bernoulli",
                    "MVS"
                  ]
                },
                "floatSet": null
              },
              "target": {
                "integerSet": {
                  "ranges": []
                },
                "categoricalSet": {
                  "categories": [
                    "None"
                  ]
                },
                "floatSet": {
                  "intervals": [
                    {
                      "left": true,
                      "right": true,
                      "lower": 0.4,
                      "upper": 1.0
                    }
                  ]
                }
              }
            }
          ]
        }
      ],
      "metadata": {
        "model": "catboost_regressor",
        "modelDescription": "The CatBoost Regressor is an implementation of gradient boosting for decision trees, specifically designed to handle categorical features effectively. CatBoost stands for 'Categorical Boosting' and is optimized to reduce overfitting and improve generalization. The model is known for its robustness and high performance in a variety of data settings, including imbalanced and sparse datasets. It incorporates multiple techniques like ordered boosting and oblivious trees to improve speed and predictive accuracy.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "Handling of Categorical Features: One of the standout features of CatBoost is its native ability to handle categorical variables, removing the need for prior encoding and thereby preventing data leakage and dimensionality increase.",
          "Robust to Overfitting: CatBoost incorporates built-in mechanisms to prevent overfitting, making it more robust for small datasets or datasets where the number of features is high compared to the number of samples.",
          "High Performance: CatBoost is often cited for its superior performance in terms of predictive accuracy, outperforming other gradient boosting and tree-based methods in various benchmarks."
        ],
        "disadvantages": [
          "Computational Complexity: CatBoost can be computationally intensive and may require longer training times compared to simpler models, especially on large datasets.",
          "Hyperparameter Tuning: While CatBoost is known for good 'out-of-the-box' performance, fine-tuning its numerous hyperparameters for optimal performance can be time-consuming and complex.",
          "Interpretability: Although it provides some tools for interpretation like feature importances, CatBoost models are generally more difficult to interpret compared to linear models due to their ensemble nature."
        ],
        "prime": [],
        "displayName": "CatBoost Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "catboost"
      }
    },
    {
      "name": "xgboost_regressor",
      "mlTask": "regression",
      "incompatibleMetrics": [
        "classification-log-loss",
        "classification-roc"
      ],
      "groups": [],
      "blackListed": false,
      "hyperParameters": [
        {
          "name": "booster",
          "label": "Booster",
          "description": "Specifies the core boosting algorithm, determining the type of base learners in the ensemble model.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "dart",
                "gbtree"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "gbtree",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bylevel",
          "label": "Column subsample ratio by level",
          "description": "Fraction of features randomly sampled for each level in the decision tree during construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bynode",
          "label": "Column subsample ratio by node",
          "description": "Fraction of features randomly sampled for each new node in the decision tree during construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "colsample_bytree",
          "label": "Column subsample ratio by tree",
          "description": "Fraction of features randomly sampled for each tree during model construction.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.1,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "gamma",
          "label": "Gamma",
          "description": "Minimum reduction in loss function required to create a new tree split, controlling model complexity and preventing overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "learning_rate",
          "label": "Learning rate",
          "description": "Step size shrinkage used in updates to prevent overfitting by shrinking feature weights, making the boosting process more conservative.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.3,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_delta_step",
          "label": "Maximum delta step",
          "description": "Maximum allowed change for each leaf output in the tree, mitigating the influence of outliers or skewed data by limiting weight updates.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1000.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "max_depth",
          "label": "Maximum depth",
          "description": "Maximum depth of the tree. Nodes are expanded until all leaves are pure or contain less than min_samples_split samples.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 3,
                  "stop": 17
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 10,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "min_child_weight",
          "label": "Minimum child weight",
          "description": "Minimum number of training examples required in each tree node to allow further splitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": false,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "n_estimators",
          "label": "Number of estimators",
          "description": "Number of trees built during the training process.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 10,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": true,
          "defaultValue": 100,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "num_parallel_tree",
          "label": "Number of parallel trees",
          "description": "Number of parallel trees constructed during each iteration, supporting boosted random forests.",
          "domain": {
            "integerSet": {
              "ranges": [
                {
                  "start": 1,
                  "stop": 101
                }
              ]
            },
            "categoricalSet": null,
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": 1,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": "uniform"
          },
          "fixedValue": false
        },
        {
          "name": "reg_alpha",
          "label": "Regularization alpha",
          "description": "Strength of L1 regularization term, penalizing absolute values of leaf node weights, promoting sparsity and reducing overfitting risk.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 0.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "reg_lambda",
          "label": "Regularization lambda",
          "description": "Strength of L2 regularization term, penalizing squared values of leaf node weights, encouraging smaller weights and reducing overfitting.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0,
                  "upper": 10.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "subsample",
          "label": "Subsample",
          "description": "Fraction of training examples randomly sampled without replacement for each tree, reducing overfitting and improving generalization.",
          "domain": {
            "integerSet": null,
            "categoricalSet": null,
            "floatSet": {
              "intervals": [
                {
                  "left": true,
                  "right": true,
                  "lower": 0.0001,
                  "upper": 1.0
                }
              ]
            }
          },
          "enabled": true,
          "defaultValue": 1.0,
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": "uniform",
            "integerDistribution": null
          },
          "fixedValue": false
        },
        {
          "name": "tree_method",
          "label": "Tree method",
          "description": "Algorithm used to construct decision trees during the training process.",
          "domain": {
            "integerSet": null,
            "categoricalSet": {
              "categories": [
                "exact",
                "hist",
                "approx",
                "gpu_hist"
              ]
            },
            "floatSet": null
          },
          "enabled": false,
          "defaultValue": "hist",
          "constraint": false,
          "constraintInformation": null,
          "distribution": {
            "categoricalDistribution": null,
            "floatDistribution": null,
            "integerDistribution": null
          },
          "fixedValue": false
        }
      ],
      "constraintEdges": [],
      "metadata": {
        "model": "xgboost_regressor",
        "modelDescription": "The XGBoost Regressor is a powerful and efficient gradient boosting model from the XGBoost library. It combines multiple weak learners, typically decision trees, to create a strong ensemble model. In each iteration, a new weak learner is added to the ensemble, focusing on correcting the errors made by the previous learners. Predictions from the ensemble model are given by a weighted sum of the predictions of the individual weak learners. XGBoost Regressor is known for its high performance, scalability, and ability to handle various data types and distributions, making it a popular choice for a wide range of machine learning tasks, especially regression problems.",
        "modelType": [
          "Ensemble Model",
          "Tree-Based Model"
        ],
        "advantages": [
          "It requires less feature engineering",
          "Feature importance can be found out",
          "It is robust to outliers",
          "It performs well on large sized datasets",
          "It is computational fast"
        ],
        "disadvantages": [
          "It has the problem of overfitting",
          "It is harder to tune as there are too many hyperparameters"
        ],
        "prime": [],
        "displayName": "XGBoost Regressor",
        "supports": {
          "probabilities": false,
          "decisionTree": false,
          "featureImportance": true
        },
        "structure": "base",
        "dependencyGroup": "xgboost"
      }
    }
  ]
}